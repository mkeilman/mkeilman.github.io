var b=Object.defineProperty;var N=(B,t,s)=>t in B?b(B,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):B[t]=s;var l=(B,t,s)=>N(B,typeof t!="symbol"?t+"":t,s);import{j as R,r as w,c as v,R as M}from"./client-DD4c7S6m.js";console.log.bind(console);class P{static capitalize(t){return t[0].toUpperCase()+t.slice(1)}static distinctElementsAtPositions(t,s){const e=[];for(const n of s)n>=0&&n<t.length&&e.push(t[n]);return e}static elementsAtPositions(t,s){return t.filter(e=>s.includes(t.indexOf(e)))}static indexArray(t){const s=new Array(t);for(let e=0;e<t;++e)s[e]=e;return s}static invertMap(t){const s=Object.values(t);if(new Set(s).size!==s.length)throw new Error("Map in not onto");const e={};return Object.keys(t).forEach((n,r)=>{e[s[r]]=n}),e}static log(...t){console.log(...t)}static randomIndicesForArrayOfSize(t){const s=[],e=P.indexArray(t);let n=0;for(let r=0;r<t;++r){const d=Math.floor(Math.random()*(t-r));s.push(e[d]),n=e[d],e[d]=e[t-r-1],e[t-r-1]=n}return s}}class Y{static poop(){}constructor(){Object.getOwnPropertyNames(this.constructor.prototype).filter(t=>t!=="constructor").forEach(t=>{this[t]=this[t].bind(this)})}funcs(){return Object.getOwnPropertyNames(this).filter(t=>typeof this[t]=="function")}objs(){return this.props().filter(t=>typeof this[t]=="object")}props(){return Object.getOwnPropertyNames(this).filter(t=>!this.funcs().includes(t))}vals(){return this.props().filter(t=>typeof this[t]!="object")}}const f=class f extends Y{static exclude(t,s){return s.filter(e=>!e.equals(t))}static highestCardInSubset(t){return t.toSorted((s,e)=>e.value()-s.value())[0]}static highestCardInSubsets(t,s){if(t.length===0||s.length===0)return null;const e=f.highestCardInSubset(t),n=f.highestCardInSubset(s);return e.equals(n)?f.highestCardInSubsets(f.exclude(e,t),f.exclude(n,s)):f.max(e,n)}static fromJSON(t){return new f(t.suit,t.rank)}static fromString(t){const s=P.invertMap(f.Ranks),e=P.invertMap(f.Suits);return new f(s[t[0]],e[t[1]])}static includes(t,s){return t.map(e=>e.toString()).includes(s.toString())}static isHighCardLess(t,s){if(t.length===0||s.length===0)return!1;const e=f.highestCardInSubset(t),n=f.highestCardInSubset(s);return e.lt(n)?!0:n.lt(e)?!1:f.isHighCardLess(f.exclude(e,t),f.exclude(n,s))}static max(t,s){return t.lt(s)?s:t}static min(t,s){return t.lt(s)?t:s}constructor(t,s){super(),this.suit=t,this.rank=s}equals(t){return this.value()===t.value()}gt(t){return this.value()>t.value()}isSameAsCard(t){return this.equals(t)&&this.suit===t.suit}lowValue(){return f.LowValues[this.rank]}lt(t){return this.value()<t.value()}toJSON(){return{suit:this.suit,rank:this.rank}}toString(){return`${f.SuitStrings[this.suit]}${f.RankStrings[this.rank]}`}value(){return f.Values[this.rank]}};l(f,"LowValues",{deuce:2,trey:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10,jack:11,queen:12,king:13,ace:1}),l(f,"Ranks",{deuce:"deuce",trey:"trey",four:"four",five:"five",six:"six",seven:"seven",eight:"eight",nine:"nine",ten:"ten",jack:"jack",queen:"queen",king:"king",ace:"ace"}),l(f,"RankStrings",{deuce:"2",trey:"3",four:"4",five:"5",six:"6",seven:"7",eight:"8",nine:"9",ten:"10",jack:"J",queen:"Q",king:"K",ace:"A"}),l(f,"Suits",{club:"club",diamond:"diamond",heart:"heart",spade:"spade"}),l(f,"SuitStrings",{club:"♣️",diamond:"♦️",heart:"♥️",spade:"♠️"}),l(f,"Values",{deuce:2,trey:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10,jack:11,queen:12,king:13,ace:14});let o=f;const m=class m extends Y{static freshCards(){const t=[];for(const s of m.suits)for(const e of m.ranks)t.push(new o(s,e));return t}static fromJSON(t){const s=t[m.KEY_POKER_DECK],e=new m(!1,s[m.KEY_POKER_DECK_DEALT_CARDS].map(n=>o.fromJSON(n)),s[m.KEY_POKER_DECK_DISCARDS].map(n=>o.fromJSON(n)));return e.cards=s[m.KEY_POKER_DECK_CARDS].map(n=>o.fromJSON(n)),e.deckIndex=s[m.KEY_POKER_DECK_INDEX],e}constructor(t=!1,s=[],e=[]){super(),this.cards=m.freshCards(),t?this.shuffle():this.setup(s,e)}burn(t=1){if(this.deckIndex+t>this.cards.length)return null;const s=[];for(let e=1;e<=t;++e){const n=this.cards[this.deckIndex];this.discards.push(n),s.push(n),this.deckIndex+=1}return s}currentCard(){return this.deckIndex<this.cards.length?this.cards[this.deckIndex]:null}dealCard(){if(this.deckIndex+1>this.cards.count)return null;const t=this.cards[this.deckIndex];return this.dealtCards.push(t),this.deckIndex+=1,t}setup(t=[],s=[]){this.dealtCards=t,this.discards=s,this.deckIndex=this.dealtCards.length+this.discards.length}shuffle(){const t=P.randomIndicesForArrayOfSize(this.cards.length),s=[];for(let e=0;e<this.cards.length;++e)s.push(this.cards[t[e]]);this.cards=s,this.setup()}toJSON(){const t={};t[m.KEY_POKER_DECK]={};const s=t[m.KEY_POKER_DECK];return s[m.KEY_POKER_DECK_CARDS]=this.cards.map(e=>e.toJSON()),s[m.KEY_POKER_DECK_DEALT_CARDS]=this.dealtCards.map(e=>e.toJSON()),s[m.KEY_POKER_DECK_DISCARDS]=this.discards.map(e=>e.toJSON()),s[m.KEY_POKER_DECK_INDEX]=this.deckIndex,t}toString(){return`${this.cards}`}};l(m,"ranks",Object.keys(o.Ranks)),l(m,"suits",Object.keys(o.Suits)),l(m,"KEY_POKER_DECK","deck"),l(m,"KEY_POKER_DECK_CARDS",`${m.KEY_POKER_DECK}.cards`),l(m,"KEY_POKER_DECK_DEALT_CARDS",`${m.KEY_POKER_DECK}.dealtCards`),l(m,"KEY_POKER_DECK_DISCARDS",`${m.KEY_POKER_DECK}.discards`),l(m,"KEY_POKER_DECK_INDEX",`${m.KEY_POKER_DECK}.deckIndex`);let k=m;const c=class c extends Y{static cardsInRankOrder(t,s=!1){const e=s?"lowValue":"value";return t.toSorted((n,r)=>n[e]()-r[e]())}static kicker(t,s){const e=t.handRank,n=s.handRank;if(e!==n||t.equals(s))return null;const r=c.max(t,s),d=c.min(t,s);return e===c.Ranks.fourOfAKind?r.cardsGroupedByRank[1][0]:e===c.Ranks.threeOfAKind||e===c.Ranks.pair?t.cardsGroupedByRank[0][0].equals(s.cardsGroupedByRank[0][0])?o.highestCardInSubsets(r.cards.filter(u=>!o.includes(r.cardsGroupedByRank[0],u)),d.cards.filter(u=>!o.includes(d.cardsGroupedByRank[0],u))):null:e===c.Ranks.twoPair&&t.cardsGroupedByRank[1][0].equals(s.cardsGroupedByRank[1][0])&&t.cardsGroupedByRank[0][0].equals(s.cardsGroupedByRank[0][0])?r.cardsGroupedByRank[2][0]:null}static kickersAgainstHands(t,s){const e=s.map(n=>o.kicker(t,n)).filter(n=>n).map(n=>n.toString());return Array.from(new Set(e)).map(n=>o.fromString(n))}static kickersDesc(t){if(!t.length)return"";let s="";for(let e=0;e<t.length-1;++e)s+=`${t[e].rank}, `;return s+`${t[t.length-1].rank} Kicker${t.length>1?"s":""}`}static max(t,s){return t.lt(s)?s:t}static min(t,s){return t.lt(s)?t:s}constructor(t){if(super(),t.length!==5)throw new Error(`Must supply 5 cards (num cards = ${t.length})`);this.cards=t,this.highestCard=o.highestCardInSubset(t),this.cardsGroupedByRank=this.groupByRank(t),this.handRank=this.getHandRank()}cardsString(){return this.cards.map(t=>t.toString())}description(t=!0,s=!1){const e=this;function n(d){return d?"Straight":`
				Straight to the ${e.isStraightAceLow(!0)?c.cardsInRankOrder(e.cards,!0)[this.cards.length-1]:e.highestCard}
			`}function r(d){if(d)return"Two Pair";const u=this.cardsGroupedByRank[0][0],h=this.cardsGroupedByRank[0][1],y=this.cardsGroupedByRank[1][0],A=this.cardsGroupedByRank[1][1];return u.rank===o.Ranks.eight&&y.rank===o.Ranks.ace&&(u.suit===o.Suits.club&&h.suit===o.Suits.spade||u.suit===o.Suits.spade&&h.suit===o.Suits.club)&&(y.suit===o.Suits.club&&A.suit===o.Suits.spade||y.suit===o.Suits.spade&&A.suit===o.Suits.club)?"Dead Man's Hand":`${y.rank.rawValue}s and ${u.rank.rawValue}s`}return this.handRank===c.Ranks.royalFlush?"Royal Flush!":this.handRank===c.Ranks.straightFlush?"Straight Flush"+s?"":` to the ${this.highestCard}`:this.handRank===c.Ranks.fourOfAKind?`Four ${this.cardsGroupedByRank[0][0].rank}s`:this.handRank===c.Ranks.fullHouse?"Full House"+s?"":` ${this.cardsGroupedByRank[0][0].rank}s over ${this.cardsGroupedByRank[1][0].rank}s`:this.handRank===c.Ranks.flush?`${t&&!s?this.cards[0].suit+" ":""}Flush`:this.handRank===c.Ranks.straight?n(s):this.handRank===c.Ranks.threeOfAKind?`Trip ${this.cardsGroupedByRank[0][0].rank}s`:this.handRank===c.Ranks.twoPair?r(s):this.handRank===c.Ranks.pair?`Pair of ${this.cardsGroupedByRank[0][0].rank}s`:`${this.highestCard} High`}getHandRank(){const t={highCard:0,pair:1,twoPair:2,threeOfAKind:3,royalFlush:9,straightFlush:8,straight:4,flush:5,fullHouse:6,fourOfAKind:7};for(const s of Object.keys(t)){const e=`is${P.capitalize(s)}`;if(this[e]&&this[e]())return t[s]}return t.highCard}groupByRank(t){const s=[];let e,n=[];for(const r of c.cardsInRankOrder(t))e&&r.gt(e)&&(s.push(n),n=[]),n.push(r),e=r;return s.push(n),s.sort((r,d)=>d.length-r.length),s}equals(t){if(this.handRank!==t.handRank)return!1;const s=this.handRank,e=this.cardsGroupedByRank;return s===c.Ranks.royalFlush?!0:s===c.Ranks.straightFlush?this.highestCard===t.highestCard:s===c.Ranks.fourOfAKind||s===c.Ranks.fullHouse?e[0][0]===t.cardsGroupedByRank[0][0]&&e[1][0]===t.cardsGroupedByRank[1][0]:s===c.Ranks.flush?o.isHighCardLess(this.cards,t.cards):s===c.Ranks.straight?this.highestCard=t.highestCard:s===c.Ranks.threeOfAKind||s===c.Ranks.twoPair?e[0][0]===t.cardsGroupedByRank[0][0]&&e[1][0]===t.cardsGroupedByRank[1][0]&&e[2][0]===t.cardsGroupedByRank[2][0]:s===c.Ranks.pair?e[0][0]!==t.cardsGroupedByRank[0][0]?!1:!o.isHighCardLess(this.cards.filter(n=>!o.includes(e[0],n)),t.cards.filter(n=>!o.includes(t.cardsGroupedByRank[0],n)))&&!o.isHighCardLess(t.cards.filter(n=>!o.includes(t.cardsGroupedByRank[0],n)),this.cards.filter(n=>!o.includes(e[0],n))):s===c.Ranks.highCard?!o.isHighCardLess(this.cards,t.cards):!1}gt(t){return!this.equals(t)&&!this.lt(t)}isFlush(){return this.cards.every(t=>t.suit===this.cards[0].suit)}isFourOfAKind(){return this.cardsGroupedByRank[0].length===4}isFullHouse(){return this.cardsGroupedByRank[0].length===3&&this.cardsGroupedByRank[1].length===2}isPair(){return this.cardsGroupedByRank[0].length===2&&this.cardsGroupedByRank[1].length===1}isRoyalFlush(){return this.isStraightFlush()&&this.highestCard.rank===o.Ranks.ace}isStraight(){return this.isStraightAceLow()?!0:this.isStraightAceLow(!0)}isStraightAceLow(t=!1){const s=t?"lowValue":"value";let e=c.cardsInRankOrder(this.cards,t),n=e[0];for(let r=1;r<e.length;++r){const d=e[r];if(d[s]()!==n[s]()+1)return!1;n=d}return!0}isStraightFlush(){return this.isStraight()&&this.isFlush()}isThreeOfAKind(){return this.cardsGroupedByRank[0].length===3&&this.cardsGroupedByRank[1].length===1}isTwoPair(){return this.cardsGroupedByRank[0].length===2&&this.cardsGroupedByRank[1].length===2}lt(t){if(this.handRank>=c.Ranks.royalFlush)return!1;if(this.handRank<t.handRank)return!0;if(this.handRank>t.handRank)return!1;const s=this.handRank,e=this.cardsGroupedByRank;if(s===c.Ranks.straightFlush)return this.highestCard.lt(t.highestCard);if(s===c.Ranks.fourOfAKind||s===c.Ranks.fullHouse)return e[0][0].lt(t.cardsGroupedByRank[0][0])?!0:e[0][0].equals(t.cardsGroupedByRank[0][0])?e[1][0].lt(t.cardsGroupedByRank[1][0]):!1;if(s===c.Ranks.flush)return o.isHighCardLess(this.cards,t.cards);if(s===c.Ranks.straight)return this.isStraightAceLow()&&t.isStraightAceLow()||this.isStraightAceLow(!0)&&t.isStraightAceLow(!0)?this.highestCard.lt(t.highestCard):this.isStraightAceLow(!0);if(s===c.Ranks.threeOfAKind)return e[0][0].lt(t.cardsGroupedByRank[0][0])?!0:e[0][0].equals(t.cardsGroupedByRank[0][0])?o.isHighCardLess(this.cards.filter(n=>!o.includes(e[0],n)),t.cards.filter(n=>!o.includes(t.cardsGroupedByRank[0],n))):!1;if(s===c.Ranks.twoPair){if(e[1][0].lt(t.cardsGroupedByRank[1][0]))return!0;if(e[1][0].equals(t.cardsGroupedByRank[1][0])){if(e[0][0].lt(t.cardsGroupedByRank[0][0]))return!0;if(e[0][0].equals(t.cardsGroupedByRank[0][0]))return e[2][0].lt(t.cardsGroupedByRank[2][0])}return!1}return s===c.Ranks.pair?e[0][0].lt(t.cardsGroupedByRank[0][0])?!0:e[0][0].equals(t.cardsGroupedByRank[0][0])?o.isHighCardLess(this.cards.filter(n=>!o.includes(e[0],n)),t.cards.filter(n=>!o.includes(t.cardsGroupedByRank[0],n))):!1:s===c.Ranks.highCard?o.isHighCardLess(this.cards,t.cards):!1}pertinentCards(){return this.isRoyalFlush()||this.isStraightFlush()||this.isStraight()||this.isFullHouse()||this.isFlush()?this.cards:this.isFourOfAKind()||this.isThreeOfAKind()||this.isPair()?this.cardsGroupedByRank[0]:this.isTwoPair()?this.cardsGroupedByRank[0].concat(this.cardsGroupedByRank[1]):this.highestCard}ranksInHand(){const t={};Object.keys(o.Ranks).forEach(s=>{t[s]=0});for(let s of this.cards)t[s.rank]=t[s.rank]+1;return t}suitsInHand(){const t={};Object.keys(o.Suits).forEach(s=>{t[s]=0});for(const s of this.cards)t[s.suit]=t[s.suit]+1;return t}toJSON(){return{cards:this.cards.map(t=>t.toJSON())}}toString(){return`${this.cards}`}};l(c,"lowestHand",new c([new o(o.Suits.club,o.Ranks.seven),new o(o.Suits.diamond,o.Ranks.five),new o(o.Suits.heart,o.Ranks.four),new o(o.Suits.spade,o.Ranks.trey),new o(o.Suits.club,o.Ranks.deuce)])),l(c,"highestHand",new c([new o(o.Suits.spade,o.Ranks.ten),new o(o.Suits.spade,o.Ranks.jack),new o(o.Suits.spade,o.Ranks.queen),new o(o.Suits.spade,o.Ranks.king),new o(o.Suits.spade,o.Ranks.ace)])),l(c,"Ranks",{highCard:0,pair:1,twoPair:2,threeOfAKind:3,straight:4,flush:5,fullHouse:6,fourOfAKind:7,straightFlush:8,royalFlush:9}),l(c,"COMBO_INDICES",[[[0,1,2]],[[0,1,2,3],[0,1,2],[0,2,3],[0,1,3],[1,2,3]],[[0,1,2,3,4],[0,1,2,3],[0,1,2,4],[0,1,3,4],[0,2,3,4],[2,3,4,1],[1,2,3,4],[0,1,2],[0,1,3],[0,1,4],[0,2,3],[0,2,4],[0,3,4],[1,2,3],[1,2,4],[1,3,4],[2,3,4]]]);let T=c;const i=class i extends Y{static isBettingAction(t){return t===i.RoundActions.smallBlind||t===i.RoundActions.bigBlind||t===i.RoundActions.bet||t===i.RoundActions.call||t===i.RoundActions.raise}static buildPlayerArray(t,s=!1){if(t<=0)return[];const e=[];for(let n=0;n<t;++n){const r=new i;s&&(r.pokerFace=self.getPokerFace(n)),e.push(r)}return e}static fromJSON(t){const s=t[i.KEY_PLAYER],e=new i(s[i.KEY_PLAYER_ID]);return e.isAssigned=s[i.KEY_PLAYER_IS_ASSIGNED],e.stake=s[i.KEY_PLAYER_STAKE],e.wentAllInPreviousRound=s[i.KEY_PLAYER_ALREADY_ALL_IN],e.gameState=s[i.KEY_PLAYER_GAME_STATE],e.handState=s[i.KEY_PLAYER_HAND_STATE],e.hasButton=s[i.KEY_PLAYER_HAS_BUTTON],e.isSmallBlind=s[i.KEY_PLAYER_IS_SMALL_BLIND],e.isBigBlind=s[i.KEY_PLAYER_IS_BIG_BLIND],e.position=s[i.KEY_PLAYER_POSITION],e.pokerFace=s[i.KEY_PLAYER_POKER_FACE],e.currentCards=s[i.KEY_PLAYER_CARDS].map(n=>o.fromJSON(n)),e.lastAction=s[i.KEY_PLAYER_LAST_ACTION],e.currentBets=s[i.KEY_PLAYER_CURRENT_BETS],e.currentBet=s[i.KEY_PLAYER_CURRENT_BET],e.lastBetInRound=s[i.KEY_PLAYER_LAST_BET],e.totalBetsInPotsInRound=s[i.KEY_PLAYER_TOTAL_BETS],e.totalBetsInHand=s[i.KEY_PLAYER_TOTAL_BET_HAND],e.totalBetsInPotsInHand=s[i.KEY_PLAYER_TOTAL_BETS_HAND],e}static getPokerFace(t=null){return t===null?i.PokerFaces.none:i.ValidFaces[t%i.ValidFaces.length]}static includes(t,s){return t.map(e=>e.playerID).includes(s.playerID)}constructor(t=null){super(),this.playerID=t||crypto.randomUUID(),this.isAssigned=!1,this.pokerFace=i.PokerFaces.none,this.stake=i.STARTING_STAKE,this.wentAllInPreviousRound=!1,this.gameState=i.PlayerGameStates.none,this.handState=i.PlayerHandStates.none,this.position=NaN,this.hasButton=!1,this.isSmallBlind=!1,this.isBigBlind=!1,this.currentCards=[],this.currentHand=[],this.currentBets=[0],this.totalBetsInPotsInRound=[0],this.totalBetsInHand=0,this.totalBetsInPotsInHand=[0],this.currentBet=0,this.lastBetInRound=0,this.lastAction=i.RoundActions.none,this.bestHandString=""}totalBetsInRound(){return this.totalBetsInPotsInRound.reduce((t,s)=>t+s,0)}equals(t){return this.playerID===p2.playerID}toJSON(){const t={},s=`${i.KEY_PLAYER}`;t[s]={};const e=t[s];return e[i.KEY_PLAYER_ID]=this.playerID,e[i.KEY_PLAYER_IS_ASSIGNED]=this.isAssigned,e[i.KEY_PLAYER_STAKE]=this.stake,e[i.KEY_PLAYER_ALREADY_ALL_IN]=this.wentAllInPreviousRound,e[i.KEY_PLAYER_GAME_STATE]=this.gameState,e[i.KEY_PLAYER_HAND_STATE]=this.handState,e[i.KEY_PLAYER_HAS_BUTTON]=this.hasButton,e[i.KEY_PLAYER_IS_SMALL_BLIND]=this.isSmallBlind,e[i.KEY_PLAYER_IS_BIG_BLIND]=this.isBigBlind,e[i.KEY_PLAYER_POSITION]=this.position,e[i.KEY_PLAYER_POKER_FACE]=this.pokerFace,e[i.KEY_PLAYER_CARDS]=this.currentCards.map(n=>n.toJSON()),e[i.KEY_PLAYER_LAST_ACTION]=this.lastAction,e[i.KEY_PLAYER_CURRENT_BETS]=this.currentBets,e[i.KEY_PLAYER_CURRENT_BET]=this.currentBet,e[i.KEY_PLAYER_LAST_BET]=this.lastBetInRound,e[i.KEY_PLAYER_TOTAL_BET]=this.totalBetsInRound(),e[i.KEY_PLAYER_TOTAL_BETS]=this.totalBetsInPotsInRound,e[i.KEY_PLAYER_TOTAL_BET_HAND]=this.totalBetsInHand,e[i.KEY_PLAYER_TOTAL_BETS_HAND]=this.totalBetsInPotsInHand,t}};l(i,"PlayerHandStates",{none:0,playing:1,folded:2,winner:3}),l(i,"PlayerGameStates",{none:0,invitedNotAccepted:1,alive:2,busted:3,invitedRejected:4,winner:5}),l(i,"RoundActions",{none:"",smallBlind:"Small",bigBlind:"Big",bet:"Bet",call:"Call",raise:"Raise",check:"Check",fold:"Fold"}),l(i,"ValidActions",[i.RoundActions.none,i.RoundActions.bet,i.RoundActions.call,i.RoundActions.raise,i.RoundActions.check,i.RoundActions.fold]),l(i,"PokerFaces",{none:"😶",cool:"😎",kiss:"😙",smile:"😀",greed:"🤑",wink:"😜",love:"😍",hmm:"🤔",poop:"💩"}),l(i,"ValidFaces",[i.PokerFaces.cool,i.PokerFaces.kiss,i.PokerFaces.smile,i.PokerFaces.greed,i.PokerFaces.wink,i.PokerFaces.love,i.PokerFaces.hmm,i.PokerFaces.poop]),l(i,"STARTING_STAKE",1e3),l(i,"KEY_PLAYER","player"),l(i,"KEY_PLAYER_IS_ASSIGNED",`${i.KEY_PLAYER}.isAssigned`),l(i,"KEY_PLAYER_STAKE",`${i.KEY_PLAYER}.stake`),l(i,"KEY_PLAYER_ALREADY_ALL_IN",`${i.KEY_PLAYER}.alreadyAllIn`),l(i,"KEY_PLAYER_GAME_STATE",`${i.KEY_PLAYER}.gameState`),l(i,"KEY_PLAYER_HAND_STATE",`${i.KEY_PLAYER}.handState`),l(i,"KEY_PLAYER_HAS_BUTTON",`${i.KEY_PLAYER}.hasButton`),l(i,"KEY_PLAYER_IS_SMALL_BLIND",`${i.KEY_PLAYER}.isSmallBlind`),l(i,"KEY_PLAYER_IS_BIG_BLIND",`${i.KEY_PLAYER}.isBigBlind`),l(i,"KEY_PLAYER_POSITION",`${i.KEY_PLAYER}.position`),l(i,"KEY_PLAYER_POKER_FACE",`${i.KEY_PLAYER}.pokerFace`),l(i,"KEY_PLAYER_CARDS",`${i.KEY_PLAYER}.cards`),l(i,"KEY_PLAYER_LAST_ACTION",`${i.KEY_PLAYER}.lastAction`),l(i,"KEY_PLAYER_CURRENT_BET",`${i.KEY_PLAYER}.currentBet`),l(i,"KEY_PLAYER_CURRENT_BETS",`${i.KEY_PLAYER}.currentBets`),l(i,"KEY_PLAYER_LAST_BET",`${i.KEY_PLAYER}.lastBet`),l(i,"KEY_PLAYER_TOTAL_BET",`${i.KEY_PLAYER}.totalBet`),l(i,"KEY_PLAYER_TOTAL_BETS",`${i.KEY_PLAYER}.totalBets`),l(i,"KEY_PLAYER_TOTAL_BET_HAND",`${i.KEY_PLAYER}.totalBetInHand`),l(i,"KEY_PLAYER_TOTAL_BETS_HAND",`${i.KEY_PLAYER}.totalBetsInHand`),l(i,"KEY_PLAYER_ID",`${i.KEY_PLAYER}.playerID`);let E=i;const g=class g extends Y{static fromJSON(t){const s=t[`${g.KEY_POT}`];return new g(s[g.KEY_POT_AMOUNT],s[g.KEY_POT_PLAYERS])}constructor(t=0,s=[]){super(),this.amount=t,this.playersInPot=s}addPlayer(t){this.hasPlayer(t)||this.playersInPot.push(t.playerID)}description(){return`Amount: ${this.amount}; players: ${this.playersInPot}`}hasPlayer(t){return this.playersInPot.includes(t.playerID)}removePlayer(t){this.hasPlayer(t)&&this.playersInPot.splice(this.playersInPot.indexOf(t.playerID),1)}toJSON(){const t={};return t[g.KEY_POT]={},t[g.KEY_POT][g.KEY_POT_AMOUNT]=this.amount,t[g.KEY_POT][g.KEY_POT_PLAYERS]=this.playersInPot,t}};l(g,"KEY_POT","pot"),l(g,"KEY_POT_AMOUNT",`${g.KEY_POT}.amount`),l(g,"KEY_POT_PLAYERS",`${g.KEY_POT}.players`);let K=g;const a=class a extends Y{static nextToken(t){const s=a.GameTokens.indexOf(t||"");return s>=0?a.GameTokens[(s+1)%a.GameTokens.length]:a.GameTokens[0]}static bestHandFromHandAndCards(t,s){return a.bestHandFromCards(t.cards,s)}static bestHandFromCards(t,s){if(t.length<3||t.length>5||s.length!==2)return null;const e=t.length===3?0:t.length===4?1:2;let n,r,d,u;for(const h of T.COMBO_INDICES[e]){u=P.distinctElementsAtPositions(t,h),r=u;const y=5-r.length,A=y===1?1:0;for(let O=0;O<=A;++O){r=u,d=[];for(let C=0;C<y;++C)d.push(s[C+O]);r=r.concat(d);const G=new T(r);(!n||G.gt(n))&&(n=G)}}return n}static fromJSON(t){const s=t[a.KEY_GAME_MODEL],e=s[a.KEY_GAME_PLAYERS].map(r=>E.fromJSON(r)),n=new a(e.length);return n.players=e,n.gameID=s[a.KEY_GAME_ID],n.stateID=s[a.KEY_GAME_STATE_ID],n.authToken=s[a.KEY_GAME_SERVER_AUTH_TOKEN],n.gameToken=s[a.KEY_GAME_TOKEN],n.state=s[a.KEY_GAME_STATE],n.deck=k.fromJSON(s[a.KEY_GAME_DECK]),n.communityCards=s[a.KEY_GAME_COMMUNITY_CARDS].map(r=>o.fromJSON(r)),n.currentPosition=s[a.KEY_GAME_CURRENT_POSITION],n.buttonPosition=s[a.KEY_GAME_BUTTON_POSITION],n.handNumber=s[a.KEY_GAME_ROUND],n.pots=s[a.KEY_GAME_POTS].map(r=>K.fromJSON(r)),n}static initWithPlayers(t){const s=new a(null,0);return s.players=t,s}constructor(t=2){super(),this.gameID=crypto.randomUUID(),this.stateID=crypto.randomUUID(),this.state=a.States.new,this.deck=new k(!0),this.state=a.States.new,this.pots=[new K],this.communityCards=[],this.players=[],this.buttonPosition=0,this.currentPosition=0,this.handNumber=0;for(let s=0;s<t;++s){const e=new E;e.gameState=E.PlayerGameStates.alive,e.position=s,this.players.push(e)}this.state=a.States.ready}allBetsEqual(){let t=this.playersInHandIncludingAllIn().length;if(t<=0)return!0;let e=this.playersInHandIncludingAllIn()[0].totalBetsInRound();for(let n=1;n<t;++n)if(this.playersInHandIncludingAllIn()[n].totalBetsInRound()===e)return!1;return!0}allBetsEqualAfterBettingAround(){for(let t=0;t<this.pots.length;++t){const s=this.pots[t];let e=this.playerWithID(s.playersInPot[0]).totalBetsInPotsInRound[t];for(let n=1;n<this.playersInPots()[t].length;++n)if(this.playersInPots()[t][n].totalBetsInPotsInRound[t]!==e)return!1}return!0}allBetsEqualForPlayersNotAllIn(){const t=this.playersInHand().length;if(t<=0)return!0;const s=this.playersInHand()[0].totalBetsInRound();for(let e=1;e<t;++e)if(this.playersInHand()[e].totalBetsInRound()!==s)return!1;return!0}bestHandForPlayer(t){return a.bestHandFromCards(this.communityCards,t.currentCards)}bigBlind(){return 2*this.smallBlind()}bigBlindPosition(){return(this.buttonPosition+(this.currentPlayers().length>2?2:1))%this.currentPlayers().length}compareBestHandsForPlayers(t,s){const e=this.bestHandForPlayer(t),n=this.bestHandForPlayer(s);return e===null?n!==null:n!==null?e-n:!1}currentPlayers(){return this.players.filter(t=>t.gameState===E.PlayerGameStates.alive||t.gameState===E.PlayerGameStates.busted||t.gameState===E.PlayerGameStates.winner)}didPlayersCheckAround(){return this.playersStillInGame().reduce((t,s)=>s&&t.lastAction===E.RoundActions.check,!0)}goToNextPosition(){this.currentPosition=this.nextPosition()}hasSmallBlindBeenPlayed(){return this.playersStillInGame().reduce((t,s)=>s||t.lastAction===E.RoundActions.smallBlind,!1)}haveAllPlayersActedThisRound(){return this.playersStillInGame().reduce((t,s)=>s&&t.lastAction!==E.RoundActions.none,!0)}haveAnyBetsBeenMadeThisRound(){return this.currentPlayers().reduce((t,s)=>t+s.totalBetsInRound(),0)>0}isBigBlindInGame(){return this.playersStillInGame().reduce((t,s)=>t||s.position===this.bigBlindPosition(),!1)}hasBigBlindBeenPlayed(){return this.playersStillInGame().reduce((t,s)=>t||s.lastAction===E.RoundActions.bigBlind,!1)}isAnyPlayerAllIn(){return this.playersSortedByTotalBetsInRound().reduce((t,s)=>t||s.stake===0,!1)}isComplete(){return a.StatesComplete.includes(this.state)}isEveryPlayerButCurrentAllIn(){return this.playersInHand().filter(t=>t.position!==this.currentPosition).reduce((t,s)=>t&&x.stake===0,!0)}isInProgress(){return a.StatesInProgress.includes(this.state)}isInviting(){return a.StatesInviting.includes(this.state)}isRoundOver(){return this.haveAllPlayersActedThisRound()?this.didPlayersCheckAround()||this.allBetsEqual()?!0:this.playersInHandIncludingAllIn().length!==2||this.lastBettingPlayer()===null?this.playersInHand().length===1?this.allBetsEqualAfterBettingAround():this.allBetsEqualForPlayersNotAllIn():!1:!1}lastBettingPlayer(){return this.lastBettingPlayerFromPlayer(this.playerAtCurrentPosition())}lastBettingPlayerFromPlayer(t){let s=t.position,e=s,n=!1,r;const d=this.currentPlayers(),u=d.length;do e=(e+u-1)%u,e!==s?(r=d[e],n=r.lastAction!==E.RoundActions.fold&&r.lastAction!==E.RoundActions.none):n=!0;while(!n);return r}lastPosition(){return(this.currentPosition+this.currentPlayers().length-1)%this.currentPlayers().length}maxBetTotal(){const t=this.playersSortedByTotalBetsInRound();return t[t.length-1].totalBetsInRound()}maxBetTotalInPot(t){const s=this.playersSortedByTotalBetsInRoundAndPot(t);return s[s.length-1].totalBetsInPotsInRound[t]}minBetTotal(){return this.playersSortedByTotalBetsInRound()[0].totalBetsInRound}minimumBet(){return this.pots.reduce((t,s,e)=>t+this.minimumBetInPot(e),0)}minimumBetInPot(t){let s=this.bigBlind();if(!this.isInProgress())return s;if(!this.haveAnyBetsBeenMadeThisRound())return t<this.pots.length-1?0:s;let e=this.maxBetTotalInPot(t);if(e===0&&!E.isBettingAction(this.playerAtCurrentPosition.lastAction)){let n=0;for(let r=t+1;r<this.pots.length;++r)n+=this.minimumBetInPot(r);if(n===0){let r=0;for(let d=0;d<t;++d)r+=this.minimumBetInPot(d);this.isEveryPlayerButCurrentAllIn()||(e=Math.max(this.maxBetTotal(),this.bigBlind())-r)}}else this.isBigBlindInGame()||e<this.bigBlind()&&(this.isAnyPlayerAllIn()||(e=this.bigBlind()));return e-this.playerAtCurrentPosition().totalBetsInPotsInRound[t]}minimumRaise(){let t=Math.max(this.currentPlayers().map(s=>s.currentBet));return t>0?2*t:2*this.bigBlind()}nextButtonPosition(){const t=this.buttonPosition;let s=t,e=!1;do s=(s+1)%this.currentPlayers().length,s!==t?e=this.currentPlayers()[s].gameState===E.PlayerGameStates.alive:e=!0;while(!e);this.buttonPosition=s}nextPosition(){const t=this.currentPosition;let s=t,e=!1;do if(s=(s+1)%this.currentPlayers().length,s!==t){const n=this.currentPlayers()[s];e=n.handState===E.PlayerGameStates.playing&&n.stake>0}else e=!0;while(!e);return s}numPlayersLeftToJoin(){return this.playersStillToJoin().length}playerAtCurrentPosition(){return this.currentPlayers()[this.currentPosition]}playerAtLastPosition(){return this.currentPlayers()[this.lastPosition]}playersInPots(){const t=[];for(const s of this.pots)t.push(s.playersInPot.filter(e=>this.playerWithID(e)).map(e=>this.playerWithID(e)));return t}playersInBestHandOrder(){return this.currentPlayers().sort(this.compareBestHandsForPlayers)}playersInHand(){return this.playersInHandIncludingAllIn().filter(t=>t.stake>0)}playersInHandIncludingAllIn(){return this.currentPlayers().filter(t=>t.handState===E.PlayerHandStates.playing&&!t.wentAllInPreviousRound)}playersOutOfGame(){return this.currentPlayers().filter(t=>t.gameState===E.PlayerHandStates.busted)}playersSortedByTotalBetsInRound(){return this.currentPlayers().filter(t=>t.totalBetsInRound()>0).sort((t,s)=>t.totalBetsInRound()-s.totalBetsInRound())}playersSortedByTotalBetsInRoundAndPot(t){return this.playersInPots()[t].filter(s=>s.totalBetsInPotsInRound[t]>0).sort((s,e)=>s.totalBetsInRound()-e.totalBetsInRound())}playersStillInGame(){return this.currentPlayers().filter(t=>t.gameState===E.PlayerGameStates.alive||t.gameState===E.PlayerGameStates.winner)}playersStillInWhoHaveBetThisRound(){return this.playersInHand().filter(t=>t.lastAction!==E.RoundActions.none)}playersStillInWhoHaveBetThisRoundExcluding(t){return this.playersStillInWhoHaveBetThisRound().filter(s=>s!==t)}playersStillToJoin(){return this.players.filter(t=>t.gameState===E.PlayerGameStates.invitedNotAccepted)}playersWhoHaveBetThisRound(){return this.playersInHandIncludingAllIn().filter(t=>E.isBettingAction(t.lastAction))}playerWithID(t){return this.players.filter(s=>s.playerID===t)[0]}positionsStillInHand(){const t=[];for(const s of this.playersInHand())t.push(s.position);return t}potsWithPlayer(t){return this.pots.filter(s=>s.playersInPot.includes(t.playerID))}raisePlus(){return this.minimumRaise()+this.minimumBet()}smallBlind(){return a.SmallBlinds[Math.min(this.handNumber,a.SmallBlinds.length-1)]}smallBlindPositon(){let t=this.currentPlayers().length>2?1:0;return(this.buttonPosition+t)%this.currentPlayers().length}toJSON(){const t=this.pots.map(n=>n.toJSON()),s={};s[`${a.KEY_GAME_MODEL}`]={};const e=s[`${a.KEY_GAME_MODEL}`];return e[`${a.KEY_GAME_ID}`]=this.gameID,e[`${a.KEY_GAME_STATE_ID}`]=this.stateID,e[`${a.KEY_GAME_STATE}`]=this.state,e[`${a.KEY_GAME_DECK}`]=this.deck.toJSON(),e[`${a.KEY_GAME_POTS}`]=t,e[`${a.KEY_GAME_COMMUNITY_CARDS}`]=this.communityCards.map(n=>n.toJSON()),e[`${a.KEY_GAME_PLAYERS}`]=this.players.map(n=>n.toJSON()),e[`${a.KEY_GAME_CURRENT_POSITION}`]=this.currentPosition,e[`${a.KEY_GAME_BUTTON_POSITION}`]=this.buttonPosition,e[`${a.KEY_GAME_ROUND}`]=this.handNumber,s}totalOfallStakesButCurrent(){let t=0;const s=this.currentPosition;let e=0;for(let n=1;n<this.currentPlayers().length;++n)e=(s+n)%this.currentPlayers().length,t+=this.currentPlayers()[e].stake;return t}winningOrSplitPlayers(){if(this.state!==a.States.handOver)return null;const t=this.playersInBestHandOrder(),s=t[this.currentPlayers().length-1],e=this.bestHandForPlayer(s),n=[s];for(let r=0;r<this.currentPlayers().length-1;++r){const d=t[r];this.bestHandForPlayer(d).equals(e)&&n.push(d)}return n}winningOrSplitPlayersInPot(t){if(this.state!==a.States.handOver&&this.state!==a.States.gameOver)return null;let s,e=t.playersInPot.filter(r=>this.playerWithID(r)!=null).map(r=>this.playerWithID(r)).filter(r=>r.handState!==E.PlayerHandStates.folded).sort(this.compareBestHandsForPlayers);const n=e[e.length-1];if(!n)return null;s=[n];for(let r=0;r<e.length-1;++r){const d=e[r];this.bestHandForPlayer(d).equals(this.bestHandForPlayer(n))&&s.push(d)}return s}winningPlayer(){return this.state===a.States.gameOver?this.playersStillInGame().filter(t=>t.gameState===E.PlayerGameStates.winner)[0]:null}};l(a,"Blinds",{small:0,big:1}),l(a,"ChipValues",[1,5,10,25,100]),l(a,"GameTokens",["♣︎♣︎","♣︎♦︎","♣︎♥︎","♣︎♠︎","♣︎♧","♣︎♢","♣︎♡","♣︎♤","♦︎♣︎","♦︎♦︎","♦︎♥︎","♦︎♠︎","♦︎♧","♦︎♢","♦︎♡","♦︎♤","♥︎♣︎","♥︎♦︎","♥︎♥︎","♥︎♠︎","♥︎♧","♥︎♢","♥︎♡","♥︎♤","♠︎♣︎","♠︎♦︎","♠︎♥︎","♠︎♠︎","♠︎♧","♠︎♢","♠︎♡","♠︎♤","♧♣︎","♧♦︎","♧♥︎","♧♠︎","♧♧","♧♢","♧♡","♧♤","♢♣︎","♢♦︎","♢♥︎","♢♠︎","♢♧","♢♢","♢♡","♢♤","♡♣︎","♡♦︎","♡♥︎","♡♠︎","♡♧","♡♢","♡♡","♡♤","♤♣︎","♤♦︎","♤♥︎","♤♠︎","♤♧","♤♢","♤♡","♤♤"]),l(a,"States",{none:"none",new:"new",invite:"invite",quorumReachedTimeRemains:"quorumReachedTimeRemains",quorumReachedTimeExpired:"quorumReachedTimeExpired",quorumFailedTimeExpired:"quorumFailedTimeExpired",ready:"ready",preFlop:"preFlop",preTurn:"preTurn",preRiver:"preRiver",finalBets:"finalBets",handOver:"handOver",gameOver:"gameOver",gameCanceled:"gameCanceled"}),l(a,"StatesComplete",[a.States.gameOver,a.States.state===a.States.quorumFailedTimeExpired,a.States.state===a.States.gameCanceled]),l(a,"StatesInProgress",[a.States.quorumReachedTimeExpired,a.States.state===a.States.ready,a.States.state===a.States.preFlop,a.States.state===a.States.preTurn,a.States.state===a.States.preRiver,a.States.state===a.States.finalBets,a.States.state===a.States.handOver]),l(a,"StatesInviting",[a.States.invite,a.States.state===a.States.quorumReachedTimeRemains]),l(a,"SmallBlinds",[5,10,15,20,25,50,75,100,150,200]),l(a,"KEY_GAME_MODEL","game"),l(a,"KEY_GAME_ID",`${a.KEY_GAME_MODEL}.gameID`),l(a,"KEY_GAME_STATE_ID",`${a.KEY_GAME_MODEL}.stateID`),l(a,"KEY_GAME_SERVER_AUTH_TOKEN",`${a.KEY_GAME_MODEL}.authToken`),l(a,"KEY_GAME_STATE",`${a.KEY_GAME_MODEL}.gameState`),l(a,"KEY_GAME_DECK",`${a.KEY_GAME_MODEL}.deck`),l(a,"KEY_GAME_POTS",`${a.KEY_GAME_MODEL}.pots`),l(a,"KEY_GAME_POT",`${a.KEY_GAME_MODEL}.pot`),l(a,"KEY_GAME_COMMUNITY_CARDS",`${a.KEY_GAME_MODEL}.communityCards`),l(a,"KEY_GAME_PLAYERS",`${a.KEY_GAME_MODEL}.players`),l(a,"KEY_GAME_CURRENT_POSITION",`${a.KEY_GAME_MODEL}.currentPosition`),l(a,"KEY_GAME_BUTTON_POSITION",`${a.KEY_GAME_MODEL}.buttonPosition`),l(a,"KEY_GAME_ROUND",`${a.KEY_GAME_MODEL}.round`),l(a,"KEY_GAME_TOKEN",`${a.KEY_GAME_MODEL}.token`);let I=a;const S=class S extends Y{constructor(t){super(),this.game=t,this.me=t.players[1],this.actions={},this.betActions={},this.raiseActions={},this.lastGoodGameState=null}shuffleUpAndDeal(){const t=this;function s(n){n.handState=E.PlayerHandStates.playing,n.lastAction=E.RoundActions.none,n.hasButton=n.position===t.game.buttonPosition,n.isSmallBlind=n.position===t.game.smallBlindPositon(),n.isBigBlind=n.position===t.game.bigBlindPosition(),n.currentBet=0,n.totalBetsInHand=0,n.currentBets[0]=0,n.totalBetsInPotsInRound[0]=0,n.wentAllInPreviousRound=!1}function e(n){n.handState=E.PlayerHandStates.none,n.lastAction=E.RoundActions.none,n.hasButton=!1,n.isSmallBlind=!1,n.isBigBlind=!1,n.currentCards=[]}if(this.game.deck.shuffle(),this.game.state===I.States.ready){for(const n of this.game.playersStillInGame())n.currentCards=[],n.currentCards.push(this.game.deck.dealCard()),n.currentCards.push(this.game.deck.dealCard());this.game.state=I.States.preFlop}for(const n of this.game.playersStillInGame())s(n);for(const n of this.game.playersOutOfGame())e(n);for(const n of this.game.playersInHand()){n.hasButton&&(this.game.currentPosition=n.position);let r=0;n.isSmallBlind&&(r=Math.min(this.game.smallBlind(),n.stake),n.lastAction=E.RoundActions.smallBlind),n.isBigBlind&&(r=Math.min(this.game.bigBlind(),n.stake),n.lastAction=E.RoundActions.bigBlind),r>0&&this.placeBlindBetForPlayer(r,n)}}determineBet(t){if(Object.keys(S.BetActions).includes(t)){if(t===S.BetActions.call)return this.me.lastAction=E.RoundActions.call,Math.min(this.game.minimumBet(),this.me.stake);if(this.me.lastAction=E.RoundActions.bet,t===S.BetActions.minBet)return Math.min(this.game.minimumBet(),this.me.stake);if(t===S.BetActions.minBetPlus)return Math.min(2*this.game.minimumBet(),this.me.stake);if(t===S.BetActions.betAllIn)return this.me.stake}return this.me.lastAction=E.RoundActions.raise,t===S.RaiseActions.minRaise?Math.min(this.game.minimumRaise(),this.me.stake):t===S.RaiseActions.minRaisePlus?Math.min(this.game.raisePlus(),this.me.stake):this.me.stake}goAllIn(){let t=!1;if(this.game.playersInHand().length>1){this.game.pots.push(new K(0,this.game.playersInHand().map(e=>e.playerID)));for(p of this.game.currentPlayers())p.currentBets.push(0),p.totalBetsInPotsInRound.push(0),p.totalBetsInPotsInHand.push(0);t=!0}const s=this.game.pots.length;for(const e of this.game.playersWhoHaveBetThisRound().filter(n=>!n.equals(this.game.me))){if(e.totalBetsInRound()<=this.me.totalBetsInRound())continue;const n=e.currentBet-this.me.totalBetsInRound();if(s>1&&t)this.game.pots[s-1].amount+=n,this.game.pots[s-2].amount-=n,e.currentBets[s-1]+=n,e.currentBets[s-2]-=n,e.totalBetsInPotsInRound[s-1]+=n,e.totalBetsInPotsInRound[s-2]-=n,e.totalBetsInPotsInHand[s-1]+=n,e.totalBetsInPotsInHand[s-2]-=n;else{let r=n;for(let d=1;d<=this.game.pots.length;++d){let u=this.game.pots.length-d;if(r>0&&E.includes(this.game.playersInPots[u],e)){const h=r>e.currentBets[u]?e.currentBets[u]:r;this.game.pots[u].amount-=h,e.totalBetsInPotsInHand[u]-=h,e.totalBetsInPotsInRound[u]-=h,e.currentBets[u]-=h,r-=h}}e.lastBetInRound-=n,e.stake+=n,e.currentBet-=n}if(e.stake>0)for(const r of this.game.pots)r.addPlayer(e)}}placeBet(t){const s=this.determineBet(t),e=[];for(let r=0;r<this.game.pots.length;++r)e.push(this.game.minimumBetInPot(r));if(this.myLastStake=this.me.stake,this.me.stake-=s,this.me.currentBet=s,this.me.lastBetInRound=s,this.me.totalBetsInHand+=s,this.game.pots.length>1){let r=s;for(let h=0;h<this.game.pots.length-1;++h){const y=this.game.pots[h];let A=e[h];r>=A?(y.amount+=A,this.me.currentBets[h]=A,this.me.totalBetsInPotsInRound[h]+=A,this.me.totalBetsInPotsInHand[h]+=A,r-=A):(y.amount+=r,this.me.currentBets[h]=r,this.me.totalBetsInPotsInRound[h]+=r,this.me.totalBetsInPotsInHand[h]+=r,r=0)}const d=this.game.pots.length-1;let u=this.game.pots[d];r>0?(u.amount+=r,this.me.currentBets[d]=r,this.me.totalBetsInPotsInRound[d]+=r,this.me.totalBetsInPotsInHand[d]+=r,r=0):this.me.stake===0&&this.me.currentBets[d]===0&&u.removePlayer(this.me)}else this.game.pots[0].amount+=s,this.me.currentBets[0]=s,this.me.totalBetsInPotsInRound[0]+=s,this.me.totalBetsInPotsInHand[0]+=s;this.me.stake===0&&this.goAllIn(),this.game.isRoundOver()?this.game.currentPosition=this.game.buttonPosition:this.game.goToNextPosition()}placeBlindBetForPlayer(t,s){const e=[];for(let u=0;u<this.game.pots.length;++u)e.push(this.game.minimumBetInPot(u));s.stake-=t,s.currentBet=t,s.lastBetInRound=t,s.totalBetsInHand+=t;let n=this.game.pots.length;if(n>1){let u=t;for(let h=0;h<this.game.pots.length;++h){let y=this.game.pots[h],A=e[h];u>=A?(y.amount+=A,s.currentBets[h]=A,s.totalBetsInPotsInRound[h]+=A,s.totalBetsInPotsInHand[h]+=A,u-=A):(y.amount+=u,s.currentBets[h]=u,s.totalBetsInPotsInRound[h]+=u,s.totalBetsInPotsInHand[h]+=u,u=0)}}else this.game.pots[0].amount+=t,s.currentBets[0]=t,s.totalBetsInPotsInRound[0]+=t,s.totalBetsInPotsInHand[0]+=t;if(s.stake>0)return;if(this.game.playersInHand().length>1){this.game.pots.push(new K(0,this.game.playersInHand.map(u=>u.playerID)));for(p of this.game.playersInHand())p.currentBets.push(0),p.totalBetsInPotsInRound.push(0),p.totalBetsInPotsInHand.push(0)}n=this.game.pots.length;let r=this.game.playersStillInWhoHaveBetThisRound(),d=r.length;for(const u of r){if(u===s||u.totalBetsInRound()<=u.totalBetsInRound())continue;let h=u.currentBet-u.totalBetsInRound();n>1&&d>1?(this.game.pots[n-1].amount+=h,this.game.pots[n-2].amount-=h,u.currentBets[n-1]+=h,u.currentBets[n-2]-=h,u.totalBetsInPotsInRound[n-1]+=h,u.totalBetsInPotsInRound[n-2]-=h,u.totalBetsInPotsInHand[n-1]+=h,u.totalBetsInPotsInHand[n-2]-=h):(this.game.pots[0].amount-=h,u.totalBetsInPotsInHand[0]-=h,u.totalBetsInPotsInRound[0]-=h,u.lastBetInRound-=h,u.stake+=h,u.currentBets[0]-=h,u.currentBet-=h)}}nextDeal(t=!0){const s={};s[`${I.States.ready}`]="shuffleUpAndDeal",s[`${I.States.preFlop}`]="flop",s[`${I.States.preTurn}`]="turn",s[`${I.States.preRiver}`]="river",(this[s[this.game.state]]||(()=>{}))(t)}flop(t=!0){if(this.game.state!==I.States.preFlop)throw new Error(`Cannot deal flop; state=${this.game.state}`);if(this.game.communityCards.length>0||!this.game.deck.burn())return!1;for(let s=1;s<=3;++s){const e=this.game.deck.dealCard();if(!e)return!1;this.game.communityCards.push(e)}return this.game.state=I.States.preTurn,this.resetForNextRound(t),!0}turn(t=!0){if(this.game.state!==I.States.preTurn)throw new Error(`Cannot deal turn; state=${this.game.state}`);if(this.game.communityCards.length!==3||!this.game.deck.burn())return!1;const s=this.game.deck.dealCard();return s?(this.game.communityCards.push(s),this.game.state=I.States.preRiver,this.resetForNextRound(t),!0):!1}river(t=!0){if(this.game.state!==I.States.preRiver)throw new Error(`Cannot deal river; state=${this.game.state}`);if(this.game.communityCards.length!==4||!this.game.deck.burn())return!1;const s=this.game.deck.dealCard();return s?(this.game.communityCards.push(s),this.game.state=I.States.finalBets,this.resetForNextRound(t),!0):!1}resetForNextRound(t=!0){t&&this.game.goToNextPosition();for(const s of this.game.currentPlayers()){s.lastAction!==E.RoundActions.fold&&(s.stake>0?(s.lastAction=E.RoundActions.none,s.lastBetInRound=0):s.lastAction.isBettingAction()&&(s.wentAllInPreviousRound=!0)),s.currentBet=0;for(let e=0;e<s.currentBets.length;++e)s.currentBets[e]=0,s.totalBetsInPotsInRound[e]=0}}};l(S,"BetActions",{betAllIn:"betAllIn",call:"call",betCancel:"betCancel",minBet:"minBet",minBetPlus:"minBetPlus",raise:"raise"}),l(S,"BetActionStrings",{betAllIn:"All In",call:"Call",betCancel:"Cancel",minBet:"",minBetPlus:"",raise:"Raise"}),l(S,"RaiseActions",{raiseAllIn:"raiseAllIn",raiseCancel:"raiseCancel",minRaise:"minRaise",minRaisePlus:"minRaisePlus"}),l(S,"RaiseActionStrings",{raiseAllIn:"All In",raiseCancel:"Cancel",minRaise:"",minRaisePlus:""}),l(S,"GameActions",{none:"none",newGame:"newGame",deal:"deal",flop:"flop",turn:"turn",river:"river",finish:"finish",show:"show",next:"next",bet:"bet",call:"call",raise:"raise",allIn:"allIn",check:"check",fold:"fold"}),l(S,"ActionStrings",{none:"",newGame:"New Game",deal:"Deal",flop:"Flop",turn:"Turn",river:"River",finish:"Finish",show:"Show Hands",next:"Next Hand",bet:"Bet",call:"Call",raise:"Raise",allIn:"All In",check:"Check",fold:"Fold"});let L=S;const D=({card:B})=>R.jsx(R.Fragment,{children:R.jsx("span",{children:B.toString()})}),F=({player:B,isBot:t=!1})=>{const s=B;return R.jsxs(R.Fragment,{children:[R.jsx("span",{children:s.pokerFace}),R.jsxs("span",{children:["Stake $",s.stake]}),R.jsx("p",{children:s.currentCards.map(e=>R.jsx(D,{card:e},e.toString()))}),!t&&R.jsx("button",{children:"Bet"})]})},$=({pot:B})=>R.jsx(R.Fragment,{children:R.jsx("span",{children:B.amount})}),H=({game:B})=>R.jsxs(R.Fragment,{children:[R.jsx("p",{children:B.communityCards.map(t=>R.jsx(D,{card:t},t.toString()))}),R.jsx("p",{children:B.pots.map((t,s)=>R.jsx($,{pot:t},s))})]}),j=()=>{let[B,t]=w.useState(()=>new I(2));const s=new L(B),e=()=>{s.nextDeal(),t(I.fromJSON(s.game.toJSON()))};return R.jsxs("div",{className:"card-table",children:[R.jsxs("div",{className:"card-table-header",children:[R.jsx("span",{className:"card-table-header-blind-value",children:s.game.smallBlind()}),R.jsx("span",{className:"card-table-header-blind-value",children:s.game.bigBlind()})]}),R.jsxs("div",{className:"card-table-header",children:[R.jsx("span",{className:"card-table-header-blind-label",children:"Small Blind"}),R.jsx("span",{className:"card-table-header-blind-label",children:"Big Blind"})]}),R.jsx("button",{children:"New Game"}),R.jsx("div",{children:"bets"}),R.jsx("div",{children:R.jsx(H,{game:s.game})}),R.jsx("div",{children:R.jsx("button",{onClick:e,children:"Deal"})}),s.game.players.map((n,r)=>R.jsx(F,{player:n,isBot:r===0},n.playerID))]})};v.createRoot(document.getElementById("root")).render(R.jsx(M.StrictMode,{children:R.jsx(j,{})}));
