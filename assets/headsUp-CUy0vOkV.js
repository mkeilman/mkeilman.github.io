var f=Object.defineProperty;var k=(u,t,s)=>t in u?f(u,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):u[t]=s;var d=(u,t,s)=>k(u,typeof t!="symbol"?t+"":t,s);import{j as c,c as x,R as g}from"./client-CADlzgmn.js";const r=class r{static exclude(t,s){return s.filter(e=>!e.equals(t))}static highestCardInSubset(t){return t.toSorted((s,e)=>e.lt(s))[0]}static highestCardInSubsets(t,s){if(t.length===0||s.length===0)return null;const e=r.highestCardInSubset(t),a=r.highestCardInSubset(s);return e.equals(a)?r.highestCardInSubsets(r.exclude(e,t),r.exclude(a,s)):Math.max(e.value(),a.value())}static fromJSON(t){return new r(t.suit,t.rank)}static isHighCardLess(t,s){if(t.length===0||s.length===0)return!1;const e=r.highestCardInSubset(t),a=r.highestCardInSubset(s);return e.lt(a)?!0:a.lt(e)?!1:r.isHighCardLess(r.exclude(e,t),r.exclude(a,s))}constructor(t,s){this.suit=r.Suits[t],this.rank=r.Ranks[s]}equals(t){return this.value()===t.value()}isSameAsCard(t){return self.equals(t)&&self.suit===t.suit}lowValue(){return r.LowValues[self.rank]}lt(t){return this.value()<t.value()}value(){return r.Values[self.rank]}toString(){return this.suit+this.rank}toJSON(){return{suit:this.suit,rank:this.rank}}};d(r,"Suits",{club:"♣️",diamond:"♦️",heart:"♥️",spade:"♠️"}),d(r,"Ranks",{deuce:"2",trey:"3",four:"4",five:"5",six:"6",seven:"7",eight:"8",nine:"9",ten:"10",jack:"J",queen:"Q",king:"K",ace:"A"}),d(r,"Values",{deuce:2,trey:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10,jack:11,queen:12,king:13,ace:14}),d(r,"LowValues",{deuce:2,trey:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10,jack:11,queen:12,king:13,ace:1});let n=r;class S{static randomIndicesForArrayOfSize(t){const s=[],e=new Array(t).fill(0);let a=0;for(let l=0;l<t;++l){const h=Math.floor(Math.random()*(t-l));s.push(e[h]),a=e[h],e[h]=e[t-l-1],e[t-l-1]=a}return s}}const i=class i{constructor(){this.cards=[],this.discards=[],this.dealtCards=[],this.deckIndex=0;for(const t in i.availableSuits)for(const s in i.availableRanks)this.cards.push(new n(t,s))}currentCard(){return this.deckIndex<this.cards.length?this.cards[this.deckIndex]:null}hasAllCards(){let t=this.cards.length===i.availableSuits.length*i.availableRanks.length;if(!t)return!1;for(const s in i.availableSuits)for(const e in i.availableRanks)t=t&&this.cards.contains(new n(s,e));return t}shuffle(){this.dealtCards=[];const t=S.randomIndicesForArrayOfSize(this.cards.length),s=[];for(let e=0;e<this.cards.length;++e)s.push(this.cards[t[e]]);this.cards=s,this.reset()}burn(t=1){if(this.deckIndex+t>this.cards.length)return null;const s=[];for(let e=1;e<=t;++e){const a=this.cards[this.deckIndex];this.discards.push(a),s.push(a),this.deckIndex+=1}return s}dealCard(){if(this.deckIndex+1>this.cards.count)return null;const t=this.cards[this.deckIndex];return this.dealtCards.push(t),this.deckIndex+=1,t}reset(){this.dealtCards=[],this.deckIndex=0,this.discards=[]}toString(){return`${this.cards}`}};d(i,"availableSuits",[n.Suits.club,n.Suits.diamond,n.Suits.heart,n.Suits.spade]),d(i,"availableRanks",[n.Ranks.ace,n.Ranks.deuce,n.Ranks.trey,n.Ranks.four,n.Ranks.five,n.Ranks.six,n.Ranks.seven,n.Ranks.eight,n.Ranks.nine,n.Ranks.ten,n.Ranks.jack,n.Ranks.queen,n.Ranks.king]);let o=i;const v=()=>{const u=new o;return c.jsxs(c.Fragment,{children:[c.jsx("h1",{children:"Heads Up!"}),c.jsx("div",{children:"bets"}),c.jsx("div",{children:"board"}),c.jsx("div",{children:u.toString()})]})};x.createRoot(document.getElementById("root")).render(c.jsx(g.StrictMode,{children:c.jsx(v,{})}));
