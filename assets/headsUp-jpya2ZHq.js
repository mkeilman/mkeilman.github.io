var f=Object.defineProperty;var B=(o,t,n)=>t in o?f(o,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):o[t]=n;var i=(o,t,n)=>B(o,typeof t!="symbol"?t+"":t,n);import{j as r,r as L,c as T,R as g}from"./client-DD4c7S6m.js";class E{static capitalize(t){return t[0].toUpperCase()+t.slice(1)}static distinctElementsAtPositions(t,n){const e=[];for(const a of n)a>=0&&a<t.length&&e.push(t[a]);return e}static elementsAtPositions(t,n){return t.filter(e=>n.includes(t.indexOf(e)))}static indexArray(t){const n=new Array(t);for(let e=0;e<t;++e)n[e]=e;return n}static invertMap(t){const n=Object.values(t);if(new Set(n).size!==n.length)throw new Error("Map in not onto");const e={};return Object.keys(t).forEach((a,l)=>{e[n[l]]=a}),e}static log(...t){console.log(...t)}static randomIndicesForArrayOfSize(t){const n=[],e=E.indexArray(t);let a=0;for(let l=0;l<t;++l){const u=Math.floor(Math.random()*(t-l));n.push(e[u]),a=e[u],e[u]=e[t-l-1],e[t-l-1]=a}return n}}class R{constructor(){Object.getOwnPropertyNames(this.constructor.prototype).filter(t=>t!=="constructor").forEach(t=>{this[t]=this[t].bind(this)})}}const c=class c extends R{static exclude(t,n){return n.filter(e=>!e.equals(t))}static highestCardInSubset(t){return t.toSorted((n,e)=>e.lt(n))[0]}static highestCardInSubsets(t,n){if(t.length===0||n.length===0)return null;const e=c.highestCardInSubset(t),a=c.highestCardInSubset(n);return e.equals(a)?c.highestCardInSubsets(c.exclude(e,t),c.exclude(a,n)):Math.max(e.value(),a.value())}static fromJSON(t){return new c(t.suit,t.rank)}static fromString(t){const n=E.invertMap(c.Ranks),e=E.invertMap(c.Suits);return new c(n[t[0]],e[t[1]])}static includes(t,n){return t.map(e=>e.toString()).includes(n.toString())}static isHighCardLess(t,n){if(t.length===0||n.length===0)return!1;const e=c.highestCardInSubset(t),a=c.highestCardInSubset(n);return e.lt(a)?!0:a.lt(e)?!1:c.isHighCardLess(c.exclude(e,t),c.exclude(a,n))}constructor(t,n){super(),this.suit=c.Suits[t],this.rank=c.Ranks[n]}equals(t){return this.value()===t.value()}isSameAsCard(t){return self.equals(t)&&self.suit===t.suit}lowValue(){return c.LowValues[self.rank]}gt(t){return this.value()>t.value()}lt(t){return this.value()<t.value()}value(){return c.Values[self.rank]}toString(){return`${this.suit}${this.rank}`}toJSON(){return{suit:this.suit,rank:this.rank}}};i(c,"Suits",{club:"♣️",diamond:"♦️",heart:"♥️",spade:"♠️"}),i(c,"Ranks",{deuce:"2",trey:"3",four:"4",five:"5",six:"6",seven:"7",eight:"8",nine:"9",ten:"10",jack:"J",queen:"Q",king:"K",ace:"A"}),i(c,"Values",{deuce:2,trey:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10,jack:11,queen:12,king:13,ace:14}),i(c,"LowValues",{deuce:2,trey:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10,jack:11,queen:12,king:13,ace:1});let h=c;const d=class d extends R{static freshCards(){const t=[];for(const n of d.suits)for(const e of d.ranks)t.push(new h(n,e));return t}constructor(t=!1,n=[],e=[]){super(),this.cards=d.freshCards(),t?this.shuffle():this.setup(n,e)}burn(t=1){if(this.deckIndex+t>this.cards.length)return null;const n=[];for(let e=1;e<=t;++e){const a=this.cards[this.deckIndex];this.discards.push(a),n.push(a),this.deckIndex+=1}return n}currentCard(){return this.deckIndex<this.cards.length?this.cards[this.deckIndex]:null}dealCard(){if(this.deckIndex+1>this.cards.count)return null;const t=this.cards[this.deckIndex];return this.dealtCards.push(t),this.deckIndex+=1,t}setup(t=[],n=[]){this.dealtCards=t,this.discards=n,this.deckIndex=this.dealtCards.length+this.discards.length}shuffle(){const t=E.randomIndicesForArrayOfSize(this.cards.length),n=[];for(let e=0;e<this.cards.length;++e)n.push(this.cards[t[e]]);this.cards=n,this.setup()}toString(){return`${this.cards}`}};i(d,"ranks",Object.keys(h.Ranks)),i(d,"suits",Object.keys(h.Suits));let A=d;const s=class s extends R{static isBettingAction(t){return t===s.RoundActions.smallBlind||t===s.RoundActions.bigBlind||t===s.RoundActions.bet||t===s.RoundActions.call||t===s.RoundActions.raise}static getPokerFace(t=null){return t===null?s.PokerFaces.none:s.ValidFaces[t%s.ValidFaces.length]}static buildPlayerArray(t,n=!1){if(t<=0)return[];const e=[];for(let a=0;a<t;++a){const l=new s;n&&(l.pokerFace=self.getPokerFace(a)),e.push(l)}return e}constructor(t=null){super(),this.playerID=t||crypto.randomUUID(),this.isAssigned=!1,this.pokerFace=s.PokerFaces.none,this.stake=s.STARTING_STAKE,this.wentAllInPreviousRound=!1,this.gameState=s.PlayerGameStates.none,this.handState=s.PlayerHandStates.none,this.position=NaN,this.hasButton=!1,this.isSmallBlind=!1,this.isBigBlind=!1,this.currentCards=[],this.currentHand=[],this.currentBets=[0],this.totalBetsInPotsInRound=[0],this.totalBetsInHand=0,this.totalBetsInPotsInHand=[0],this.currentBet=0,this.lastBetInRound=0,this.lastAction=s.RoundActions.none,this.bestHandString=""}totalBetsInRound(){return this.totalBetsInPotsInRound.reduce((t,n)=>t+n,0)}equals(t){return this.playerID===p2.playerID}toJSON(){const t={},n=`${s.KEY_PLAYER}`;t[n]={};const e=t[n];return e[`${s.KEY_PLAYER_ID}`]=this.playerID,e[`${s.KEY_PLAYER_IS_ASSIGNED}`]=this.isAssigned,e[`${s.KEY_PLAYER_STAKE}`]=this.stake,e[`${s.KEY_PLAYER_ALREADY_ALL_IN}`]=this.wentAllInPreviousRound,e[`${s.KEY_PLAYER_GAME_STATE}`]=this.gameState,e[`${s.KEY_PLAYER_HAND_STATE}`]=this.handState,e[`${s.KEY_PLAYER_HAS_BUTTON}`]=this.hasButton,e[`${s.KEY_PLAYER_IS_SMALL_BLIND}`]=this.isSmallBlind,e[`${s.KEY_PLAYER_IS_BIG_BLIND}`]=this.isBigBlind,e[`${s.KEY_PLAYER_POSITION}`]=this.position,e[`${s.KEY_PLAYER_POKER_FACE}`]=this.pokerFace,e[`${s.KEY_PLAYER_CARDS}`]=this.currentCards.map(a=>a.toJSON()),e[`${s.KEY_PLAYER_LAST_ACTION}`]=this.lastAction,e[`${s.KEY_PLAYER_CURRENT_BETS}`]=this.currentBets,e[`${s.KEY_PLAYER_CURRENT_BET}`]=this.currentBet,e[`${s.KEY_PLAYER_LAST_BET}`]=this.lastBetInRound,e[`${s.KEY_PLAYER_TOTAL_BET}`]=this.totalBetsInRound(),e[`${s.KEY_PLAYER_TOTAL_BETS}`]=this.totalBetsInPotsInRound,e[`${s.KEY_PLAYER_TOTAL_BET_HAND}`]=this.totalBetsInHand,e[`${s.KEY_PLAYER_TOTAL_BETS_HAND}`]=this.totalBetsInPotsInHand,t}};i(s,"PlayerHandStates",{none:0,playing:1,folded:2,winner:3}),i(s,"PlayerGameStates",{none:0,invitedNotAccepted:1,alive:2,busted:3,invitedRejected:4,winner:5}),i(s,"RoundActions",{none:"",smallBlind:"Small",bigBlind:"Big",bet:"Bet",call:"Call",raise:"Raise",check:"Check",fold:"Fold"}),i(s,"ValidActions",[s.RoundActions.none,s.RoundActions.bet,s.RoundActions.call,s.RoundActions.raise,s.RoundActions.check,s.RoundActions.fold]),i(s,"PokerFaces",{none:"😶",cool:"😎",kiss:"😙",smile:"😀",greed:"🤑",wink:"😜",love:"😍",hmm:"🤔",poop:"💩"}),i(s,"ValidFaces",[s.PokerFaces.cool,s.PokerFaces.kiss,s.PokerFaces.smile,s.PokerFaces.greed,s.PokerFaces.wink,s.PokerFaces.love,s.PokerFaces.hmm,s.PokerFaces.poop]),i(s,"STARTING_STAKE",1e3),i(s,"KEY_PLAYER","player"),i(s,"KEY_PLAYER_IS_ASSIGNED",s.KEY_PLAYER+".isAssigned"),i(s,"KEY_PLAYER_STAKE",s.KEY_PLAYER+".stake"),i(s,"KEY_PLAYER_ALREADY_ALL_IN",s.KEY_PLAYER+".alreadyAllIn"),i(s,"KEY_PLAYER_GAME_STATE",s.KEY_PLAYER+".gameState"),i(s,"KEY_PLAYER_HAND_STATE",s.KEY_PLAYER+".handState"),i(s,"KEY_PLAYER_HAS_BUTTON",s.KEY_PLAYER+".hasButton"),i(s,"KEY_PLAYER_IS_SMALL_BLIND",s.KEY_PLAYER+".isSmallBlind"),i(s,"KEY_PLAYER_IS_BIG_BLIND",s.KEY_PLAYER+".isBigBlind"),i(s,"KEY_PLAYER_POSITION",s.KEY_PLAYER+".position"),i(s,"KEY_PLAYER_POKER_FACE",s.KEY_PLAYER+".pokerFace"),i(s,"KEY_PLAYER_CARDS",s.KEY_PLAYER+".cards"),i(s,"KEY_PLAYER_LAST_ACTION",s.KEY_PLAYER+".lastAction"),i(s,"KEY_PLAYER_CURRENT_BET",s.KEY_PLAYER+".currentBet"),i(s,"KEY_PLAYER_CURRENT_BETS",s.KEY_PLAYER+".currentBets"),i(s,"KEY_PLAYER_LAST_BET",s.KEY_PLAYER+".lastBet"),i(s,"KEY_PLAYER_TOTAL_BET",s.KEY_PLAYER+".totalBet"),i(s,"KEY_PLAYER_TOTAL_BETS",s.KEY_PLAYER+".totalBets"),i(s,"KEY_PLAYER_TOTAL_BET_HAND",s.KEY_PLAYER+".totalBetInHand"),i(s,"KEY_PLAYER_TOTAL_BETS_HAND",s.KEY_PLAYER+".totalBetsInHand"),i(s,"KEY_PLAYER_ID",s.KEY_PLAYER+".playerID");let Y=s;const I=({card:o})=>r.jsx(r.Fragment,{children:r.jsx("span",{children:o.toString()})}),x=({deck:o})=>{const t=o||new A;return r.jsx(r.Fragment,{children:r.jsx("p",{children:t.cards.map((n,e)=>r.jsx(I,{card:n},e))})})},S=({player:o,isBot:t=!1})=>{const n=o||new Y;return r.jsxs(r.Fragment,{children:[r.jsx("span",{children:n.pokerFace}),r.jsxs("span",{children:["Stake $",n.stake]}),r.jsx("p",{children:n.currentCards.map((e,a)=>r.jsx(I,{card:e},a))}),!t&&r.jsx("button",{children:"Bet"})]})},m=()=>{let[o,t]=L.useState(()=>new A),[n,e]=L.useState(()=>[new Y,new Y]),a=0;const l=n.length,u=()=>{const K=o.dealCard();n[a].currentCards.push(K),a=(a+1)%l},p=()=>{t(new A(!0))};return r.jsxs(r.Fragment,{children:[r.jsx("h1",{children:"Heads Up!"}),r.jsx("div",{children:"bets"}),r.jsx("div",{children:"board"}),r.jsxs("div",{children:[r.jsx(x,{deck:o}),r.jsx("button",{onClick:p,children:"Shuffle"}),r.jsx("button",{onClick:u,children:"Deal"})]}),r.jsx("div",{children:r.jsx(S,{player:n[0],isBot:"true"})}),r.jsx("div",{children:r.jsx(S,{player:n[1]})})]})};T.createRoot(document.getElementById("root")).render(r.jsx(g.StrictMode,{children:r.jsx(m,{})}));
