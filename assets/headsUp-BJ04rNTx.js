var G=Object.defineProperty;var D=(B,t,s)=>t in B?G(B,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):B[t]=s;var u=(B,t,s)=>D(B,typeof t!="symbol"?t+"":t,s);import{j as A,r as N,c as M,R as w}from"./client-DD4c7S6m.js";console.log.bind(console);class y{static capitalize(t){return t[0].toUpperCase()+t.slice(1)}static distinctElementsAtPositions(t,s){const e=[];for(const n of s)n>=0&&n<t.length&&e.push(t[n]);return e}static elementsAtPositions(t,s){return t.filter(e=>s.includes(t.indexOf(e)))}static indexArray(t){const s=new Array(t);for(let e=0;e<t;++e)s[e]=e;return s}static invertMap(t){const s=Object.values(t);if(new Set(s).size!==s.length)throw new Error("Map in not onto");const e={};return Object.keys(t).forEach((n,a)=>{e[s[a]]=n}),e}static log(...t){console.log(...t)}static randomIndicesForArrayOfSize(t){const s=[],e=y.indexArray(t);let n=0;for(let a=0;a<t;++a){const h=Math.floor(Math.random()*(t-a));s.push(e[h]),n=e[h],e[h]=e[t-a-1],e[t-a-1]=n}return s}}class Y{constructor(){Object.getOwnPropertyNames(this.constructor.prototype).filter(t=>t!=="constructor").forEach(t=>{this[t]=this[t].bind(this)})}funcs(){return Object.getOwnPropertyNames(this).filter(t=>typeof this[t]=="function")}objs(){return this.props().filter(t=>typeof this[t]=="object")}props(){return Object.getOwnPropertyNames(this).filter(t=>!this.funcs().includes(t))}vals(){return this.props().filter(t=>typeof this[t]!="object")}}const f=class f extends Y{static exclude(t,s){return s.filter(e=>!e.equals(t))}static highestCardInSubset(t){return t.toSorted((s,e)=>e.value()-s.value())[0]}static highestCardInSubsets(t,s){if(t.length===0||s.length===0)return null;const e=f.highestCardInSubset(t),n=f.highestCardInSubset(s);return e.equals(n)?f.highestCardInSubsets(f.exclude(e,t),f.exclude(n,s)):f.max(e,n)}static fromJSON(t){return new f(t.suit,t.rank)}static fromString(t){const s=y.invertMap(f.Ranks),e=y.invertMap(f.Suits);return new f(s[t[0]],e[t[1]])}static includes(t,s){return t.map(e=>e.toString()).includes(s.toString())}static isHighCardLess(t,s){if(t.length===0||s.length===0)return!1;const e=f.highestCardInSubset(t),n=f.highestCardInSubset(s);return e.lt(n)?!0:n.lt(e)?!1:f.isHighCardLess(f.exclude(e,t),f.exclude(n,s))}static max(t,s){return t.lt(s)?s:t}static min(t,s){return t.lt(s)?t:s}constructor(t,s){super(),this.suit=t,this.rank=s}equals(t){return this.value()===t.value()}gt(t){return this.value()>t.value()}isSameAsCard(t){return this.equals(t)&&this.suit===t.suit}lowValue(){return f.LowValues[this.rank]}lt(t){return this.value()<t.value()}toJSON(){return{suit:this.suit,rank:this.rank}}toString(){return`${f.SuitStrings[this.suit]}${f.RankStrings[this.rank]}`}value(){return f.Values[this.rank]}};u(f,"LowValues",{deuce:2,trey:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10,jack:11,queen:12,king:13,ace:1}),u(f,"Ranks",{deuce:"deuce",trey:"trey",four:"four",five:"five",six:"six",seven:"seven",eight:"eight",nine:"nine",ten:"ten",jack:"jack",queen:"queen",king:"king",ace:"ace"}),u(f,"RankStrings",{deuce:"2",trey:"3",four:"4",five:"5",six:"6",seven:"7",eight:"8",nine:"9",ten:"10",jack:"J",queen:"Q",king:"K",ace:"A"}),u(f,"Suits",{club:"club",diamond:"diamond",heart:"heart",spade:"spade"}),u(f,"SuitStrings",{club:"â™£ï¸",diamond:"â™¦ï¸",heart:"â™¥ï¸",spade:"â™ ï¸"}),u(f,"Values",{deuce:2,trey:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10,jack:11,queen:12,king:13,ace:14});let l=f;const R=class R extends Y{static freshCards(){const t=[];for(const s of R.suits)for(const e of R.ranks)t.push(new l(s,e));return t}static fromJSON(t){const s=t[R.KEY_POKER_DECK],e=new R(!1,s[R.KEY_POKER_DECK_DEALT_CARDS].map(n=>l.fromJSON(n)),s[R.KEY_POKER_DECK_DISCARDS].map(n=>l.fromJSON(n)));return e.cards=s[R.KEY_POKER_DECK_CARDS].map(n=>l.fromJSON(n)),e.deckIndex=s[R.KEY_POKER_DECK_INDEX],e}constructor(t=!1,s=[],e=[]){super(),this.cards=R.freshCards(),t?this.shuffle():this.setup(s,e)}burn(t=1){if(this.deckIndex+t>this.cards.length)return null;const s=[];for(let e=1;e<=t;++e){const n=this.cards[this.deckIndex];this.discards.push(n),s.push(n),this.deckIndex+=1}return s}currentCard(){return this.deckIndex<this.cards.length?this.cards[this.deckIndex]:null}dealCard(){if(this.deckIndex+1>this.cards.count)return null;const t=this.cards[this.deckIndex];return this.dealtCards.push(t),this.deckIndex+=1,t}setup(t=[],s=[]){this.dealtCards=t,this.discards=s,this.deckIndex=this.dealtCards.length+this.discards.length}shuffle(){const t=y.randomIndicesForArrayOfSize(this.cards.length),s=[];for(let e=0;e<this.cards.length;++e)s.push(this.cards[t[e]]);this.cards=s,this.setup()}toJSON(){const t={};t[R.KEY_POKER_DECK]={};const s=t[R.KEY_POKER_DECK];return s[R.KEY_POKER_DECK_CARDS]=this.cards.map(e=>e.toJSON()),s[R.KEY_POKER_DECK_DEALT_CARDS]=this.dealtCards.map(e=>e.toJSON()),s[R.KEY_POKER_DECK_DISCARDS]=this.discards.map(e=>e.toJSON()),s[R.KEY_POKER_DECK_INDEX]=this.deckIndex,t}toString(){return`${this.cards}`}};u(R,"ranks",Object.keys(l.Ranks)),u(R,"suits",Object.keys(l.Suits)),u(R,"KEY_POKER_DECK","deck"),u(R,"KEY_POKER_DECK_CARDS",`${R.KEY_POKER_DECK}.cards`),u(R,"KEY_POKER_DECK_DEALT_CARDS",`${R.KEY_POKER_DECK}.dealtCards`),u(R,"KEY_POKER_DECK_DISCARDS",`${R.KEY_POKER_DECK}.discards`),u(R,"KEY_POKER_DECK_INDEX",`${R.KEY_POKER_DECK}.deckIndex`);let P=R;const c=class c extends Y{static cardsInRankOrder(t,s=!1){const e=s?"lowValue":"value";return t.toSorted((n,a)=>n[e]()-a[e]())}static kicker(t,s){const e=t.handRank,n=s.handRank;if(e!==n||t.equals(s))return null;const a=c.max(t,s),h=c.min(t,s);return e===c.Ranks.fourOfAKind?a.cardsGroupedByRank[1][0]:e===c.Ranks.threeOfAKind||e===c.Ranks.pair?t.cardsGroupedByRank[0][0].equals(s.cardsGroupedByRank[0][0])?l.highestCardInSubsets(a.cards.filter(o=>!l.includes(a.cardsGroupedByRank[0],o)),h.cards.filter(o=>!l.includes(h.cardsGroupedByRank[0],o))):null:e===c.Ranks.twoPair&&t.cardsGroupedByRank[1][0].equals(s.cardsGroupedByRank[1][0])&&t.cardsGroupedByRank[0][0].equals(s.cardsGroupedByRank[0][0])?a.cardsGroupedByRank[2][0]:null}static kickersAgainstHands(t,s){const e=s.map(n=>l.kicker(t,n)).filter(n=>n).map(n=>n.toString());return Array.from(new Set(e)).map(n=>l.fromString(n))}static kickersDesc(t){if(!t.length)return"";let s="";for(let e=0;e<t.length-1;++e)s+=`${t[e].rank}, `;return s+`${t[t.length-1].rank} Kicker${t.length>1?"s":""}`}static max(t,s){return t.lt(s)?s:t}static min(t,s){return t.lt(s)?t:s}constructor(t){if(super(),t.length!==5)throw new Error(`Must supply 5 cards (num cards = ${t.length})`);this.cards=t,this.highestCard=l.highestCardInSubset(t),this.cardsGroupedByRank=this.groupByRank(t),this.handRank=this.getHandRank()}cardsString(){return this.cards.map(t=>t.toString())}description(t=!0,s=!1){const e=this;function n(h){return h?"Straight":`
				Straight to the ${e.isStraightAceLow(!0)?c.cardsInRankOrder(e.cards,!0)[this.cards.length-1]:e.highestCard}
			`}function a(h){if(h)return"Two Pair";const o=this.cardsGroupedByRank[0][0],E=this.cardsGroupedByRank[0][1],I=this.cardsGroupedByRank[1][0],m=this.cardsGroupedByRank[1][1];return o.rank===l.Ranks.eight&&I.rank===l.Ranks.ace&&(o.suit===l.Suits.club&&E.suit===l.Suits.spade||o.suit===l.Suits.spade&&E.suit===l.Suits.club)&&(I.suit===l.Suits.club&&m.suit===l.Suits.spade||I.suit===l.Suits.spade&&m.suit===l.Suits.club)?"Dead Man's Hand":`${I.rank.rawValue}s and ${o.rank.rawValue}s`}return this.handRank===c.Ranks.royalFlush?"Royal Flush!":this.handRank===c.Ranks.straightFlush?"Straight Flush"+s?"":` to the ${this.highestCard}`:this.handRank===c.Ranks.fourOfAKind?`Four ${this.cardsGroupedByRank[0][0].rank}s`:this.handRank===c.Ranks.fullHouse?"Full House"+s?"":` ${this.cardsGroupedByRank[0][0].rank}s over ${this.cardsGroupedByRank[1][0].rank}s`:this.handRank===c.Ranks.flush?`${t&&!s?this.cards[0].suit+" ":""}Flush`:this.handRank===c.Ranks.straight?n(s):this.handRank===c.Ranks.threeOfAKind?`Trip ${this.cardsGroupedByRank[0][0].rank}s`:this.handRank===c.Ranks.twoPair?a(s):this.handRank===c.Ranks.pair?`Pair of ${this.cardsGroupedByRank[0][0].rank}s`:`${this.highestCard} High`}getHandRank(){const t={highCard:0,pair:1,twoPair:2,threeOfAKind:3,royalFlush:9,straightFlush:8,straight:4,flush:5,fullHouse:6,fourOfAKind:7};for(const s of Object.keys(t)){const e=`is${y.capitalize(s)}`;if(this[e]&&this[e]())return t[s]}return t.highCard}groupByRank(t){const s=[];let e,n=[];for(const a of c.cardsInRankOrder(t))e&&a.gt(e)&&(s.push(n),n=[]),n.push(a),e=a;return s.push(n),s.sort((a,h)=>h.length-a.length),s}equals(t){if(this.handRank!==t.handRank)return!1;const s=this.handRank,e=this.cardsGroupedByRank;return s===c.Ranks.royalFlush?!0:s===c.Ranks.straightFlush?this.highestCard===t.highestCard:s===c.Ranks.fourOfAKind||s===c.Ranks.fullHouse?e[0][0]===t.cardsGroupedByRank[0][0]&&e[1][0]===t.cardsGroupedByRank[1][0]:s===c.Ranks.flush?l.isHighCardLess(this.cards,t.cards):s===c.Ranks.straight?this.highestCard=t.highestCard:s===c.Ranks.threeOfAKind||s===c.Ranks.twoPair?e[0][0]===t.cardsGroupedByRank[0][0]&&e[1][0]===t.cardsGroupedByRank[1][0]&&e[2][0]===t.cardsGroupedByRank[2][0]:s===c.Ranks.pair?e[0][0]!==t.cardsGroupedByRank[0][0]?!1:!l.isHighCardLess(this.cards.filter(n=>!l.includes(e[0],n)),t.cards.filter(n=>!l.includes(t.cardsGroupedByRank[0],n)))&&!l.isHighCardLess(t.cards.filter(n=>!l.includes(t.cardsGroupedByRank[0],n)),this.cards.filter(n=>!l.includes(e[0],n))):s===c.Ranks.highCard?!l.isHighCardLess(this.cards,t.cards):!1}gt(t){return!this.equals(t)&&!this.lt(t)}isFlush(){return this.cards.every(t=>t.suit===this.cards[0].suit)}isFourOfAKind(){return this.cardsGroupedByRank[0].length===4}isFullHouse(){return this.cardsGroupedByRank[0].length===3&&this.cardsGroupedByRank[1].length===2}isPair(){return this.cardsGroupedByRank[0].length===2&&this.cardsGroupedByRank[1].length===1}isRoyalFlush(){return this.isStraightFlush()&&this.highestCard.rank===l.Ranks.ace}isStraight(){return this.isStraightAceLow()?!0:this.isStraightAceLow(!0)}isStraightAceLow(t=!1){const s=t?"lowValue":"value";let e=c.cardsInRankOrder(this.cards,t),n=e[0];for(let a=1;a<e.length;++a){const h=e[a];if(h[s]()!==n[s]()+1)return!1;n=h}return!0}isStraightFlush(){return this.isStraight()&&this.isFlush()}isThreeOfAKind(){return this.cardsGroupedByRank[0].length===3&&this.cardsGroupedByRank[1].length===1}isTwoPair(){return this.cardsGroupedByRank[0].length===2&&this.cardsGroupedByRank[1].length===2}lt(t){if(this.handRank>=c.Ranks.royalFlush)return!1;if(this.handRank<t.handRank)return!0;if(this.handRank>t.handRank)return!1;const s=this.handRank,e=this.cardsGroupedByRank;if(s===c.Ranks.straightFlush)return this.highestCard.lt(t.highestCard);if(s===c.Ranks.fourOfAKind||s===c.Ranks.fullHouse)return e[0][0].lt(t.cardsGroupedByRank[0][0])?!0:e[0][0].equals(t.cardsGroupedByRank[0][0])?e[1][0].lt(t.cardsGroupedByRank[1][0]):!1;if(s===c.Ranks.flush)return l.isHighCardLess(this.cards,t.cards);if(s===c.Ranks.straight)return this.isStraightAceLow()&&t.isStraightAceLow()||this.isStraightAceLow(!0)&&t.isStraightAceLow(!0)?this.highestCard.lt(t.highestCard):this.isStraightAceLow(!0);if(s===c.Ranks.threeOfAKind)return e[0][0].lt(t.cardsGroupedByRank[0][0])?!0:e[0][0].equals(t.cardsGroupedByRank[0][0])?l.isHighCardLess(this.cards.filter(n=>!l.includes(e[0],n)),t.cards.filter(n=>!l.includes(t.cardsGroupedByRank[0],n))):!1;if(s===c.Ranks.twoPair){if(e[1][0].lt(t.cardsGroupedByRank[1][0]))return!0;if(e[1][0].equals(t.cardsGroupedByRank[1][0])){if(e[0][0].lt(t.cardsGroupedByRank[0][0]))return!0;if(e[0][0].equals(t.cardsGroupedByRank[0][0]))return e[2][0].lt(t.cardsGroupedByRank[2][0])}return!1}return s===c.Ranks.pair?e[0][0].lt(t.cardsGroupedByRank[0][0])?!0:e[0][0].equals(t.cardsGroupedByRank[0][0])?l.isHighCardLess(this.cards.filter(n=>!l.includes(e[0],n)),t.cards.filter(n=>!l.includes(t.cardsGroupedByRank[0],n))):!1:s===c.Ranks.highCard?l.isHighCardLess(this.cards,t.cards):!1}pertinentCards(){return this.isRoyalFlush()||this.isStraightFlush()||this.isStraight()||this.isFullHouse()||this.isFlush()?this.cards:this.isFourOfAKind()||this.isThreeOfAKind()||this.isPair()?this.cardsGroupedByRank[0]:this.isTwoPair()?this.cardsGroupedByRank[0].concat(this.cardsGroupedByRank[1]):this.highestCard}ranksInHand(){const t={};Object.keys(l.Ranks).forEach(s=>{t[s]=0});for(let s of this.cards)t[s.rank]=t[s.rank]+1;return t}suitsInHand(){const t={};Object.keys(l.Suits).forEach(s=>{t[s]=0});for(const s of this.cards)t[s.suit]=t[s.suit]+1;return t}toJSON(){return{cards:this.cards.map(t=>t.toJSON())}}toString(){return`${this.cards}`}};u(c,"lowestHand",new c([new l(l.Suits.club,l.Ranks.seven),new l(l.Suits.diamond,l.Ranks.five),new l(l.Suits.heart,l.Ranks.four),new l(l.Suits.spade,l.Ranks.trey),new l(l.Suits.club,l.Ranks.deuce)])),u(c,"highestHand",new c([new l(l.Suits.spade,l.Ranks.ten),new l(l.Suits.spade,l.Ranks.jack),new l(l.Suits.spade,l.Ranks.queen),new l(l.Suits.spade,l.Ranks.king),new l(l.Suits.spade,l.Ranks.ace)])),u(c,"Ranks",{highCard:0,pair:1,twoPair:2,threeOfAKind:3,straight:4,flush:5,fullHouse:6,fourOfAKind:7,straightFlush:8,royalFlush:9}),u(c,"COMBO_INDICES",[[[0,1,2]],[[0,1,2,3],[0,1,2],[0,2,3],[0,1,3],[1,2,3]],[[0,1,2,3,4],[0,1,2,3],[0,1,2,4],[0,1,3,4],[0,2,3,4],[2,3,4,1],[1,2,3,4],[0,1,2],[0,1,3],[0,1,4],[0,2,3],[0,2,4],[0,3,4],[1,2,3],[1,2,4],[1,3,4],[2,3,4]]]);let K=c;const r=class r extends Y{static isBettingAction(t){return t===r.RoundActions.smallBlind||t===r.RoundActions.bigBlind||t===r.RoundActions.bet||t===r.RoundActions.call||t===r.RoundActions.raise}static buildPlayerArray(t,s=!1){if(t<=0)return[];const e=[];for(let n=0;n<t;++n){const a=new r;s&&(a.pokerFace=self.getPokerFace(n)),e.push(a)}return e}static fromJSON(t){const s=t[r.KEY_PLAYER],e=new r(s[r.KEY_PLAYER_ID]);return e.isAssigned=s[r.KEY_PLAYER_IS_ASSIGNED],e.stake=s[r.KEY_PLAYER_STAKE],e.wentAllInPreviousRound=s[r.KEY_PLAYER_ALREADY_ALL_IN],e.gameState=s[r.KEY_PLAYER_GAME_STATE],e.handState=s[r.KEY_PLAYER_HAND_STATE],e.hasButton=s[r.KEY_PLAYER_HAS_BUTTON],e.isSmallBlind=s[r.KEY_PLAYER_IS_SMALL_BLIND],e.isBigBlind=s[r.KEY_PLAYER_IS_BIG_BLIND],e.position=s[r.KEY_PLAYER_POSITION],e.pokerFace=s[r.KEY_PLAYER_POKER_FACE],e.currentCards=s[r.KEY_PLAYER_CARDS].map(n=>l.fromJSON(n)),e.lastAction=s[r.KEY_PLAYER_LAST_ACTION],e.currentBets=s[r.KEY_PLAYER_CURRENT_BETS],e.currentBet=s[r.KEY_PLAYER_CURRENT_BET],e.lastBetInRound=s[r.KEY_PLAYER_LAST_BET],e.totalBetsInPotsInRound=s[r.KEY_PLAYER_TOTAL_BETS],e.totalBetsInHand=s[r.KEY_PLAYER_TOTAL_BET_HAND],e.totalBetsInPotsInHand=s[r.KEY_PLAYER_TOTAL_BETS_HAND],e}static getPokerFace(t=null){return t===null?r.PokerFaces.none:r.ValidFaces[t%r.ValidFaces.length]}constructor(t=null){super(),this.playerID=t||crypto.randomUUID(),this.isAssigned=!1,this.pokerFace=r.PokerFaces.none,this.stake=r.STARTING_STAKE,this.wentAllInPreviousRound=!1,this.gameState=r.PlayerGameStates.none,this.handState=r.PlayerHandStates.none,this.position=NaN,this.hasButton=!1,this.isSmallBlind=!1,this.isBigBlind=!1,this.currentCards=[],this.currentHand=[],this.currentBets=[0],this.totalBetsInPotsInRound=[0],this.totalBetsInHand=0,this.totalBetsInPotsInHand=[0],this.currentBet=0,this.lastBetInRound=0,this.lastAction=r.RoundActions.none,this.bestHandString=""}totalBetsInRound(){return this.totalBetsInPotsInRound.reduce((t,s)=>t+s,0)}equals(t){return this.playerID===p2.playerID}toJSON(){const t={},s=`${r.KEY_PLAYER}`;t[s]={};const e=t[s];return e[r.KEY_PLAYER_ID]=this.playerID,e[r.KEY_PLAYER_IS_ASSIGNED]=this.isAssigned,e[r.KEY_PLAYER_STAKE]=this.stake,e[r.KEY_PLAYER_ALREADY_ALL_IN]=this.wentAllInPreviousRound,e[r.KEY_PLAYER_GAME_STATE]=this.gameState,e[r.KEY_PLAYER_HAND_STATE]=this.handState,e[r.KEY_PLAYER_HAS_BUTTON]=this.hasButton,e[r.KEY_PLAYER_IS_SMALL_BLIND]=this.isSmallBlind,e[r.KEY_PLAYER_IS_BIG_BLIND]=this.isBigBlind,e[r.KEY_PLAYER_POSITION]=this.position,e[r.KEY_PLAYER_POKER_FACE]=this.pokerFace,e[r.KEY_PLAYER_CARDS]=this.currentCards.map(n=>n.toJSON()),e[r.KEY_PLAYER_LAST_ACTION]=this.lastAction,e[r.KEY_PLAYER_CURRENT_BETS]=this.currentBets,e[r.KEY_PLAYER_CURRENT_BET]=this.currentBet,e[r.KEY_PLAYER_LAST_BET]=this.lastBetInRound,e[r.KEY_PLAYER_TOTAL_BET]=this.totalBetsInRound(),e[r.KEY_PLAYER_TOTAL_BETS]=this.totalBetsInPotsInRound,e[r.KEY_PLAYER_TOTAL_BET_HAND]=this.totalBetsInHand,e[r.KEY_PLAYER_TOTAL_BETS_HAND]=this.totalBetsInPotsInHand,t}};u(r,"PlayerHandStates",{none:0,playing:1,folded:2,winner:3}),u(r,"PlayerGameStates",{none:0,invitedNotAccepted:1,alive:2,busted:3,invitedRejected:4,winner:5}),u(r,"RoundActions",{none:"",smallBlind:"Small",bigBlind:"Big",bet:"Bet",call:"Call",raise:"Raise",check:"Check",fold:"Fold"}),u(r,"ValidActions",[r.RoundActions.none,r.RoundActions.bet,r.RoundActions.call,r.RoundActions.raise,r.RoundActions.check,r.RoundActions.fold]),u(r,"PokerFaces",{none:"ðŸ˜¶",cool:"ðŸ˜Ž",kiss:"ðŸ˜™",smile:"ðŸ˜€",greed:"ðŸ¤‘",wink:"ðŸ˜œ",love:"ðŸ˜",hmm:"ðŸ¤”",poop:"ðŸ’©"}),u(r,"ValidFaces",[r.PokerFaces.cool,r.PokerFaces.kiss,r.PokerFaces.smile,r.PokerFaces.greed,r.PokerFaces.wink,r.PokerFaces.love,r.PokerFaces.hmm,r.PokerFaces.poop]),u(r,"STARTING_STAKE",1e3),u(r,"KEY_PLAYER","player"),u(r,"KEY_PLAYER_IS_ASSIGNED",`${r.KEY_PLAYER}.isAssigned`),u(r,"KEY_PLAYER_STAKE",`${r.KEY_PLAYER}.stake`),u(r,"KEY_PLAYER_ALREADY_ALL_IN",`${r.KEY_PLAYER}.alreadyAllIn`),u(r,"KEY_PLAYER_GAME_STATE",`${r.KEY_PLAYER}.gameState`),u(r,"KEY_PLAYER_HAND_STATE",`${r.KEY_PLAYER}.handState`),u(r,"KEY_PLAYER_HAS_BUTTON",`${r.KEY_PLAYER}.hasButton`),u(r,"KEY_PLAYER_IS_SMALL_BLIND",`${r.KEY_PLAYER}.isSmallBlind`),u(r,"KEY_PLAYER_IS_BIG_BLIND",`${r.KEY_PLAYER}.isBigBlind`),u(r,"KEY_PLAYER_POSITION",`${r.KEY_PLAYER}.position`),u(r,"KEY_PLAYER_POKER_FACE",`${r.KEY_PLAYER}.pokerFace`),u(r,"KEY_PLAYER_CARDS",`${r.KEY_PLAYER}.cards`),u(r,"KEY_PLAYER_LAST_ACTION",`${r.KEY_PLAYER}.lastAction`),u(r,"KEY_PLAYER_CURRENT_BET",`${r.KEY_PLAYER}.currentBet`),u(r,"KEY_PLAYER_CURRENT_BETS",`${r.KEY_PLAYER}.currentBets`),u(r,"KEY_PLAYER_LAST_BET",`${r.KEY_PLAYER}.lastBet`),u(r,"KEY_PLAYER_TOTAL_BET",`${r.KEY_PLAYER}.totalBet`),u(r,"KEY_PLAYER_TOTAL_BETS",`${r.KEY_PLAYER}.totalBets`),u(r,"KEY_PLAYER_TOTAL_BET_HAND",`${r.KEY_PLAYER}.totalBetInHand`),u(r,"KEY_PLAYER_TOTAL_BETS_HAND",`${r.KEY_PLAYER}.totalBetsInHand`),u(r,"KEY_PLAYER_ID",`${r.KEY_PLAYER}.playerID`);let d=r;const g=class g extends Y{static fromJSON(t){const s=t[`${g.KEY_POT}`];return new g(s[g.KEY_POT_AMOUNT],s[g.KEY_POT_PLAYERS])}constructor(t=0,s=[]){super(),this.amount=t,this.playersInPot=s}addPlayer(t){this.hasPlayer(t)||this.playersInPot.push(t.playerID)}description(){return`Amount: ${this.amount}; players: ${this.playersInPot}`}hasPlayer(t){return this.playersInPot.includes(t.playerID)}removePlayer(t){this.hasPlayer(t)&&this.playersInPot.splice(this.playersInPot.indexOf(t.playerID),1)}toJSON(){const t={};return t[g.KEY_POT]={},t[g.KEY_POT][g.KEY_POT_AMOUNT]=this.amount,t[g.KEY_POT][g.KEY_POT_PLAYERS]=this.playersInPot,t}};u(g,"KEY_POT","pot"),u(g,"KEY_POT_AMOUNT",`${g.KEY_POT}.amount`),u(g,"KEY_POT_PLAYERS",`${g.KEY_POT}.players`);let k=g;const i=class i extends Y{static nextToken(t){const s=i.GameTokens.indexOf(t||"");return s>=0?i.GameTokens[(s+1)%i.GameTokens.length]:i.GameTokens[0]}static bestHandFromHandAndCards(t,s){return i.bestHandFromCards(t.cards,s)}static bestHandFromCards(t,s){if(t.length<3||t.length>5||s.length!==2)return null;const e=t.length===3?0:t.length===4?1:2;let n,a,h,o;for(const E of K.COMBO_INDICES[e]){o=y.distinctElementsAtPositions(t,E),a=o;const I=5-a.length,m=I===1?1:0;for(let O=0;O<=m;++O){a=o,h=[];for(let T=0;T<I;++T)h.push(s[T+O]);a=a.concat(h);const L=new K(a);(!n||L.gt(n))&&(n=L)}}return n}static fromJSON(t){const s=t[i.KEY_GAME_MODEL],e=s[i.KEY_GAME_PLAYERS].map(a=>d.fromJSON(a)),n=new i(e.length);return n.players=e,n.gameID=s[i.KEY_GAME_ID],n.stateID=s[i.KEY_GAME_STATE_ID],n.authToken=s[i.KEY_GAME_SERVER_AUTH_TOKEN],n.gameToken=s[i.KEY_GAME_TOKEN],n.state=s[i.KEY_GAME_STATE],n.deck=P.fromJSON(s[i.KEY_GAME_DECK]),n.communityCards=s[i.KEY_GAME_COMMUNITY_CARDS].map(a=>l.fromJSON(a)),n.currentPosition=s[i.KEY_GAME_CURRENT_POSITION],n.buttonPosition=s[i.KEY_GAME_BUTTON_POSITION],n.handNumber=s[i.KEY_GAME_ROUND],n.pots=s[i.KEY_GAME_POTS].map(a=>k.fromJSON(a)),n}static initWithPlayers(t){const s=new i(null,0);return s.players=t,s}constructor(t=2){super(),this.gameID=crypto.randomUUID(),this.stateID=crypto.randomUUID(),this.state=i.States.new,this.deck=new P(!0),this.state=i.States.new,this.pots=[],this.communityCards=[],this.players=[],this.buttonPosition=0,this.currentPosition=0,this.handNumber=0;for(let s=0;s<t;++s){const e=new d;e.gameState=d.PlayerGameStates.alive,e.position=s,this.players.push(e)}this.state=i.States.ready}allBetsEqual(){let t=this.playersInHandIncludingAllIn().length;if(t<=0)return!0;let e=this.playersInHandIncludingAllIn()[0].totalBetsInRound();for(let n=1;n<t;++n)if(this.playersInHandIncludingAllIn()[n].totalBetsInRound()===e)return!1;return!0}allBetsEqualAfterBettingAround(){for(let t=0;t<this.pots.length;++t){const s=this.pots[t];let e=this.playerWithID(s.playersInPot[0]).totalBetsInPotsInRound[t];for(let n=1;n<this.playersInPots()[t].length;++n)if(this.playersInPots()[t][n].totalBetsInPotsInRound[t]!==e)return!1}return!0}allBetsEqualForPlayersNotAllIn(){const t=this.playersInHand().length;if(t<=0)return!0;const s=this.playersInHand()[0].totalBetsInRound();for(let e=1;e<t;++e)if(this.playersInHand()[e].totalBetsInRound()!==s)return!1;return!0}bestHandForPlayer(t){return i.bestHandFromCards(this.communityCards,t.currentCards)}bigBlind(){return 2*this.smallBlind()}bigBlindPosition(){return(this.buttonPosition+(this.currentPlayers().length>2?2:1))%this.currentPlayers().length}compareBestHandsForPlayers(t,s){const e=this.bestHandForPlayer(t),n=this.bestHandForPlayer(s);return e===null?n!==null:n!==null?e-n:!1}currentPlayers(){return this.players.filter(t=>t.gameState===d.PlayerGameStates.alive||t.gameState===d.PlayerGameStates.busted||t.gameState===d.PlayerGameStates.winner)}didPlayersCheckAround(){return this.playersStillInGame().reduce((t,s)=>s&&t.lastAction===d.RoundActions.check,!0)}goToNextPosition(){this.currentPosition=this.nextPosition()}hasSmallBlindBeenPlayed(){return this.playersStillInGame().reduce((t,s)=>s||t.lastAction===d.RoundActions.smallBlind,!1)}haveAllPlayersActedThisRound(){return this.playersStillInGame().reduce((t,s)=>s&&t.lastAction!==d.RoundActions.none,!0)}haveAnyBetsBeenMadeThisRound(){return this.currentPlayers().reduce((t,s)=>t+s.totalBetsInRound(),0)>0}isBigBlindInGame(){return this.playersStillInGame().reduce((t,s)=>t||s.position===this.bigBlindPosition(),!1)}hasBigBlindBeenPlayed(){return this.playersStillInGame().reduce((t,s)=>t||s.lastAction===d.RoundActions.bigBlind,!1)}isAnyPlayerAllIn(){return this.playersSortedByTotalBetsInRound().reduce((t,s)=>t||s.stake===0,!1)}isComplete(){return i.StatesComplete.includes(this.state)}isEveryPlayerButCurrentAllIn(){return this.playersInHand().filter(t=>t.position!==this.currentPosition).reduce((t,s)=>t&&x.stake===0,!0)}isInProgress(){return i.StatesInProgress.includes(this.state)}isInviting(){return i.StatesInviting.includes(this.state)}isRoundOver(){return this.haveAllPlayersActedThisRound()?this.didPlayersCheckAround()||this.allBetsEqual()?!0:this.playersInHandIncludingAllIn().length!==2||this.lastBettingPlayer()===null?this.playersInHand().length===1?this.allBetsEqualAfterBettingAround():this.allBetsEqualForPlayersNotAllIn():!1:!1}lastBettingPlayer(){return this.lastBettingPlayerFromPlayer(this.playerAtCurrentPosition())}lastBettingPlayerFromPlayer(t){let s=t.position,e=s,n=!1,a;const h=this.currentPlayers(),o=h.length;do e=(e+o-1)%o,e!==s?(a=h[e],n=a.lastAction!==d.RoundActions.fold&&a.lastAction!==d.RoundActions.none):n=!0;while(!n);return a}lastPosition(){return(this.currentPosition+this.currentPlayers().length-1)%this.currentPlayers().length}maxBetTotal(){const t=this.playersSortedByTotalBetsInRound();return t[t.length-1].totalBetsInRound()}maxBetTotalInPot(t){const s=this.playersSortedByTotalBetsInRoundAndPot(t);return s[s.length-1].totalBetsInPotsInRound[t]}minBetTotal(){return this.playersSortedByTotalBetsInRound()[0].totalBetsInRound}minimumBet(){return this.pots.reduce((t,s,e)=>t+this.minimumBetInPot(e),0)}minimumBetInPot(t){let s=this.bigBlind();if(!this.isInProgress())return s;if(!this.haveAnyBetsBeenMadeThisRound())return t<this.pots.length-1?0:s;let e=this.maxBetTotalInPot(t);if(e===0&&!d.isBettingAction(this.playerAtCurrentPosition.lastAction)){let n=0;for(let a=t+1;a<this.pots.length;++a)n+=this.minimumBetInPot(a);if(n===0){let a=0;for(let h=0;h<t;++h)a+=this.minimumBetInPot(h);this.isEveryPlayerButCurrentAllIn()||(e=Math.max(this.maxBetTotal(),this.bigBlind())-a)}}else this.isBigBlindInGame()||e<this.bigBlind()&&(this.isAnyPlayerAllIn()||(e=this.bigBlind()));return e-this.playerAtCurrentPosition().totalBetsInPotsInRound[t]}minimumRaise(){let t=Math.max(this.currentPlayers().map(s=>s.currentBet));return t>0?2*t:2*this.bigBlind()}nextButtonPosition(){const t=this.buttonPosition;let s=t,e=!1;do s=(s+1)%this.currentPlayers().length,s!==t?e=this.currentPlayers()[s].gameState===d.PlayerGameStates.alive:e=!0;while(!e);this.buttonPosition=s}nextPosition(){const t=this.currentPosition;let s=t,e=!1;do if(s=(s+1)%this.currentPlayers().length,s!==t){const n=this.currentPlayers()[s];e=n.handState===d.PlayerGameStates.playing&&n.stake>0}else e=!0;while(!e);return s}numPlayersLeftToJoin(){return this.playersStillToJoin().length}playerAtCurrentPosition(){return this.currentPlayers()[this.currentPosition]}playerAtLastPosition(){return this.currentPlayers()[this.lastPosition]}playersInPots(){const t=[];for(const s of this.pots)t.push(s.playersInPot.filter(e=>this.playerWithID(e)).map(e=>this.playerWithID(e)));return t}playersInBestHandOrder(){return this.currentPlayers().sort(this.compareBestHandsForPlayers)}playersInHand(){return this.playersInHandIncludingAllIn().filter(t=>t.stake>0)}playersInHandIncludingAllIn(){return this.currentPlayers().filter(t=>t.handState===d.PlayerHandStates.playing&&!t.wentAllInPreviousRound)}playersOutOfGame(){return this.currentPlayers().filter(t=>t.gameState===d.PlayerHandStates.busted)}playersSortedByTotalBetsInRound(){return this.currentPlayers().filter(t=>t.totalBetsInRound()>0).sort((t,s)=>t.totalBetsInRound()-s.totalBetsInRound())}playersSortedByTotalBetsInRoundAndPot(t){return this.playersInPots()[t].filter(s=>s.totalBetsInPotsInRound[t]>0).sort((s,e)=>s.totalBetsInRound()-e.totalBetsInRound())}playersStillInGame(){return this.currentPlayers().filter(t=>t.gameState===d.PlayerGameStates.alive||t.gameState===d.PlayerGameStates.winner)}playersStillInWhoHaveBetThisRound(){return this.playersInHand().filter(t=>t.lastAction!==d.RoundActions.none)}playersStillInWhoHaveBetThisRoundExcluding(t){return this.playersStillInWhoHaveBetThisRound().filter(s=>s!==t)}playersStillToJoin(){return this.players.filter(t=>t.gameState===d.PlayerGameStates.invitedNotAccepted)}playersWhoHaveBetThisRound(){return this.playersInHandIncludingAllIn().filter(t=>d.isBettingAction(t.lastAction))}playerWithID(t){return this.players.filter(s=>s.playerID===t)[0]}positionsStillInHand(){const t=[];for(const s of this.playersInHand())t.push(s.position);return t}potsWithPlayer(t){return this.pots.filter(s=>s.playersInPot.includes(t.playerID))}raisePlus(){return this.minimumRaise()+this.minimumBet()}smallBlind(){return i.SmallBlinds[Math.min(this.handNumber,i.SmallBlinds.length-1)]}smallBlindPositon(){let t=this.currentPlayers().length>2?1:0;return(this.buttonPosition+t)%this.currentPlayers().length}toJSON(){const t=this.pots.map(n=>n.toJSON()),s={};s[`${i.KEY_GAME_MODEL}`]={};const e=s[`${i.KEY_GAME_MODEL}`];return e[`${i.KEY_GAME_ID}`]=this.gameID,e[`${i.KEY_GAME_STATE_ID}`]=this.stateID,e[`${i.KEY_GAME_STATE}`]=this.state,e[`${i.KEY_GAME_DECK}`]=this.deck.toJSON(),e[`${i.KEY_GAME_POTS}`]=t,e[`${i.KEY_GAME_COMMUNITY_CARDS}`]=this.communityCards.map(n=>n.toJSON()),e[`${i.KEY_GAME_PLAYERS}`]=this.players.map(n=>n.toJSON()),e[`${i.KEY_GAME_CURRENT_POSITION}`]=this.currentPosition,e[`${i.KEY_GAME_BUTTON_POSITION}`]=this.buttonPosition,e[`${i.KEY_GAME_ROUND}`]=this.handNumber,s}totalOfallStakesButCurrent(){let t=0;const s=this.currentPosition;let e=0;for(let n=1;n<this.currentPlayers().length;++n)e=(s+n)%this.currentPlayers().length,t+=this.currentPlayers()[e].stake;return t}winningOrSplitPlayers(){if(this.state!==i.States.handOver)return null;const t=this.playersInBestHandOrder(),s=t[this.currentPlayers().length-1],e=this.bestHandForPlayer(s),n=[s];for(let a=0;a<this.currentPlayers().length-1;++a){const h=t[a];this.bestHandForPlayer(h).equals(e)&&n.push(h)}return n}winningOrSplitPlayersInPot(t){if(this.state!==i.States.handOver&&this.state!==i.States.gameOver)return null;let s,e=t.playersInPot.filter(a=>this.playerWithID(a)!=null).map(a=>this.playerWithID(a)).filter(a=>a.handState!==d.PlayerHandStates.folded).sort(this.compareBestHandsForPlayers);const n=e[e.length-1];if(!n)return null;s=[n];for(let a=0;a<e.length-1;++a){const h=e[a];this.bestHandForPlayer(h).equals(this.bestHandForPlayer(n))&&s.push(h)}return s}winningPlayer(){return this.state===i.States.gameOver?this.playersStillInGame().filter(t=>t.gameState===d.PlayerGameStates.winner)[0]:null}};u(i,"Blinds",{small:0,big:1}),u(i,"ChipValues",[1,5,10,25,100]),u(i,"GameTokens",["â™£ï¸Žâ™£ï¸Ž","â™£ï¸Žâ™¦ï¸Ž","â™£ï¸Žâ™¥ï¸Ž","â™£ï¸Žâ™ ï¸Ž","â™£ï¸Žâ™§","â™£ï¸Žâ™¢","â™£ï¸Žâ™¡","â™£ï¸Žâ™¤","â™¦ï¸Žâ™£ï¸Ž","â™¦ï¸Žâ™¦ï¸Ž","â™¦ï¸Žâ™¥ï¸Ž","â™¦ï¸Žâ™ ï¸Ž","â™¦ï¸Žâ™§","â™¦ï¸Žâ™¢","â™¦ï¸Žâ™¡","â™¦ï¸Žâ™¤","â™¥ï¸Žâ™£ï¸Ž","â™¥ï¸Žâ™¦ï¸Ž","â™¥ï¸Žâ™¥ï¸Ž","â™¥ï¸Žâ™ ï¸Ž","â™¥ï¸Žâ™§","â™¥ï¸Žâ™¢","â™¥ï¸Žâ™¡","â™¥ï¸Žâ™¤","â™ ï¸Žâ™£ï¸Ž","â™ ï¸Žâ™¦ï¸Ž","â™ ï¸Žâ™¥ï¸Ž","â™ ï¸Žâ™ ï¸Ž","â™ ï¸Žâ™§","â™ ï¸Žâ™¢","â™ ï¸Žâ™¡","â™ ï¸Žâ™¤","â™§â™£ï¸Ž","â™§â™¦ï¸Ž","â™§â™¥ï¸Ž","â™§â™ ï¸Ž","â™§â™§","â™§â™¢","â™§â™¡","â™§â™¤","â™¢â™£ï¸Ž","â™¢â™¦ï¸Ž","â™¢â™¥ï¸Ž","â™¢â™ ï¸Ž","â™¢â™§","â™¢â™¢","â™¢â™¡","â™¢â™¤","â™¡â™£ï¸Ž","â™¡â™¦ï¸Ž","â™¡â™¥ï¸Ž","â™¡â™ ï¸Ž","â™¡â™§","â™¡â™¢","â™¡â™¡","â™¡â™¤","â™¤â™£ï¸Ž","â™¤â™¦ï¸Ž","â™¤â™¥ï¸Ž","â™¤â™ ï¸Ž","â™¤â™§","â™¤â™¢","â™¤â™¡","â™¤â™¤"]),u(i,"States",{none:"none",new:"new",invite:"invite",quorumReachedTimeRemains:"quorumReachedTimeRemains",quorumReachedTimeExpired:"quorumReachedTimeExpired",quorumFailedTimeExpired:"quorumFailedTimeExpired",ready:"ready",preFlop:"preFlop",preTurn:"preTurn",preRiver:"preRiver",finalBets:"finalBets",handOver:"handOver",gameOver:"gameOver",gameCanceled:"gameCanceled"}),u(i,"StatesComplete",[i.States.gameOver,i.States.state===i.States.quorumFailedTimeExpired,i.States.state===i.States.gameCanceled]),u(i,"StatesInProgress",[i.States.quorumReachedTimeExpired,i.States.state===i.States.ready,i.States.state===i.States.preFlop,i.States.state===i.States.preTurn,i.States.state===i.States.preRiver,i.States.state===i.States.finalBets,i.States.state===i.States.handOver]),u(i,"StatesInviting",[i.States.invite,i.States.state===i.States.quorumReachedTimeRemains]),u(i,"SmallBlinds",[5,10,15,20,25,50,75,100,150,200]),u(i,"KEY_GAME_MODEL","game"),u(i,"KEY_GAME_ID",`${i.KEY_GAME_MODEL}.gameID`),u(i,"KEY_GAME_STATE_ID",`${i.KEY_GAME_MODEL}.stateID`),u(i,"KEY_GAME_SERVER_AUTH_TOKEN",`${i.KEY_GAME_MODEL}.authToken`),u(i,"KEY_GAME_STATE",`${i.KEY_GAME_MODEL}.gameState`),u(i,"KEY_GAME_DECK",`${i.KEY_GAME_MODEL}.deck`),u(i,"KEY_GAME_POTS",`${i.KEY_GAME_MODEL}.pots`),u(i,"KEY_GAME_POT",`${i.KEY_GAME_MODEL}.pot`),u(i,"KEY_GAME_COMMUNITY_CARDS",`${i.KEY_GAME_MODEL}.communityCards`),u(i,"KEY_GAME_PLAYERS",`${i.KEY_GAME_MODEL}.players`),u(i,"KEY_GAME_CURRENT_POSITION",`${i.KEY_GAME_MODEL}.currentPosition`),u(i,"KEY_GAME_BUTTON_POSITION",`${i.KEY_GAME_MODEL}.buttonPosition`),u(i,"KEY_GAME_ROUND",`${i.KEY_GAME_MODEL}.round`),u(i,"KEY_GAME_TOKEN",`${i.KEY_GAME_MODEL}.token`);let S=i;class b extends Y{constructor(t){super(),this.game=t,this.lastGoodGameState=null}shuffleUpAndDeal(){const t=this;function s(n){n.handState=d.PlayerHandStates.playing,n.lastAction=d.RoundActions.none,n.hasButton=n.position===t.game.buttonPosition,n.isSmallBlind=n.position===t.game.smallBlindPositon(),n.isBigBlind=n.position===t.game.bigBlindPosition(),n.currentBet=0,n.totalBetsInHand=0,n.currentBets[0]=0,n.totalBetsInPotsInRound[0]=0,n.wentAllInPreviousRound=!1}function e(n){n.handState=d.PlayerHandStates.none,n.lastAction=d.RoundActions.none,n.hasButton=!1,n.isSmallBlind=!1,n.isBigBlind=!1,n.currentCards=[]}if(this.game.deck.shuffle(),this.game.state===S.States.ready){for(const n of this.game.playersStillInGame())n.currentCards=[],n.currentCards.push(this.game.deck.dealCard()),n.currentCards.push(this.game.deck.dealCard());this.game.state=S.States.preFlop}for(const n of this.game.playersStillInGame())s(n);for(const n of this.game.playersOutOfGame())e(n);for(const n of this.game.playersInHand()){n.hasButton&&(this.game.currentPosition=n.position);let a=0;n.isSmallBlind&&(a=Math.min(this.game.smallBlind,n.stake),n.lastAction=d.RoundActions.smallBlind),n.isBigBlind&&(a=Math.min(this.game.bigBlind,n.stake),n.lastAction=d.RoundActions.bigBlind),a>0&&this.placeBlindBetForPlayer(a,n)}}placeBlindBetForPlayer(t,s){const e=[];for(let o=0;o<this.game.pots.length;++o)e.push(this.game.minimumBetInPot(o));s.stake-=t,s.currentBet=t,s.lastBetInRound=t,s.totalBetsInHand+=t;let n=this.game.pots.length;if(n>1){let o=t;for(let E=0;E<this.game.pots.length;++E){let I=this.game.pots[E],m=e[E];o>=m?(I.amount+=m,s.currentBets[E]=m,s.totalBetsInPotsInRound[E]+=m,s.totalBetsInPotsInHand[E]+=m,o-=m):(I.amount+=o,s.currentBets[E]=o,s.totalBetsInPotsInRound[E]+=o,s.totalBetsInPotsInHand[E]+=o,o=0)}}else this.game.pots[0].amount+=t,s.currentBets[0]=t,s.totalBetsInPotsInRound[0]+=t,s.totalBetsInPotsInHand[0]+=t;if(s.stake>0)return;if(this.game.playersInHand().length>1){this.game.pots.push(new k(0,this.game.playersInHand.map(o=>o.playerID)));for(p of this.game.playersInHand())p.currentBets.push(0),p.totalBetsInPotsInRound.push(0),p.totalBetsInPotsInHand.push(0)}n=this.game.pots.length;let a=this.game.playersStillInWhoHaveBetThisRound(),h=a.length;for(const o of a){if(o===s||o.totalBetsInRound()<=o.totalBetsInRound())continue;let E=o.currentBet-o.totalBetsInRound();n>1&&h>1?(this.game.pots[n-1].amount+=E,this.game.pots[n-2].amount-=E,o.currentBets[n-1]+=E,o.currentBets[n-2]-=E,o.totalBetsInPotsInRound[n-1]+=E,o.totalBetsInPotsInRound[n-2]-=E,o.totalBetsInPotsInHand[n-1]+=E,o.totalBetsInPotsInHand[n-2]-=E):(this.game.pots[0].amount-=E,o.totalBetsInPotsInHand[0]-=E,o.totalBetsInPotsInRound[0]-=E,o.lastBetInRound-=E,o.stake+=E,o.currentBets[0]-=E,o.currentBet-=E)}}nextDeal(t=!0){const s={};s[`${S.States.ready}`]="shuffleUpAndDeal",s[`${S.States.preFlop}`]="flop",s[`${S.States.preTurn}`]="turn",s[`${S.States.preRiver}`]="river",(this[s[this.game.state]]||(()=>{}))(t)}flop(t=!0){if(this.game.state!==S.States.preFlop)throw new Error(`Cannot deal flop; state=${this.game.state}`);if(this.game.communityCards.length>0||!this.game.deck.burn())return!1;for(let s=1;s<=3;++s){const e=this.game.deck.dealCard();if(!e)return!1;this.game.communityCards.push(e)}return this.game.state=S.States.preTurn,this.resetForNextRound(t),!0}turn(t=!0){if(this.game.state!==S.States.preTurn)throw new Error(`Cannot deal turn; state=${this.game.state}`);if(this.game.communityCards.length!==3||!this.game.deck.burn())return!1;const s=this.game.deck.dealCard();return s?(this.game.communityCards.push(s),this.game.state=S.States.preRiver,this.resetForNextRound(t),!0):!1}river(t=!0){if(this.game.state!==S.States.preRiver)throw new Error(`Cannot deal river; state=${this.game.state}`);if(this.game.communityCards.length!==4||!this.game.deck.burn())return!1;const s=this.game.deck.dealCard();return s?(this.game.communityCards.push(s),this.game.state=S.States.finalBets,this.resetForNextRound(t),!0):!1}resetForNextRound(t=!0){t&&this.game.goToNextPosition();for(const s of this.game.currentPlayers()){s.lastAction!==d.RoundActions.fold&&(s.stake>0?(s.lastAction=d.RoundActions.none,s.lastBetInRound=0):s.lastAction.isBettingAction()&&(s.wentAllInPreviousRound=!0)),s.currentBet=0;for(let e=0;e<s.currentBets.length;++e)s.currentBets[e]=0,s.totalBetsInPotsInRound[e]=0}}}const C=({card:B})=>A.jsx(A.Fragment,{children:A.jsx("span",{children:B.toString()})}),v=({player:B,isBot:t=!1})=>{const s=B;return A.jsxs(A.Fragment,{children:[A.jsx("span",{children:s.pokerFace}),A.jsxs("span",{children:["Stake $",s.stake]}),A.jsx("p",{children:s.currentCards.map(e=>A.jsx(C,{card:e},e.toString()))}),!t&&A.jsx("button",{children:"Bet"})]})},F=({game:B})=>A.jsx(A.Fragment,{children:A.jsx("p",{children:B.communityCards.map(t=>A.jsx(C,{card:t},t.toString()))})}),$=()=>{let[B,t]=N.useState(()=>new S(2));const s=new b(B),e=()=>{s.nextDeal(),t(S.fromJSON(s.game.toJSON()))};return A.jsxs(A.Fragment,{children:[A.jsx("h1",{children:"Heads Up!"}),A.jsx("button",{children:"New Game"}),A.jsx("div",{children:"bets"}),A.jsx("div",{children:A.jsx(F,{game:s.game})}),A.jsx("div",{children:A.jsx("button",{onClick:e,children:"Deal"})}),s.game.players.map((n,a)=>A.jsx(v,{player:n,isBot:a===0},n.playerID))]})};M.createRoot(document.getElementById("root")).render(A.jsx(w.StrictMode,{children:A.jsx($,{})}));
