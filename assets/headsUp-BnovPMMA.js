var D=Object.defineProperty;var N=(f,t,s)=>t in f?D(f,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):f[t]=s;var u=(f,t,s)=>N(f,typeof t!="symbol"?t+"":t,s);import{j as h,r as k,c as M,R as b}from"./client-DD4c7S6m.js";const w=console.log.bind(console);class g{static capitalize(t){return t[0].toUpperCase()+t.slice(1)}static distinctElementsAtPositions(t,s){const e=[];for(const n of s)n>=0&&n<t.length&&e.push(t[n]);return e}static elementsAtPositions(t,s){return t.filter(e=>s.includes(t.indexOf(e)))}static indexArray(t){const s=new Array(t);for(let e=0;e<t;++e)s[e]=e;return s}static invertMap(t){const s=Object.values(t);if(new Set(s).size!==s.length)throw new Error("Map in not onto");const e={};return Object.keys(t).forEach((n,l)=>{e[s[l]]=n}),e}static log(...t){console.log(...t)}static randomIndicesForArrayOfSize(t){const s=[],e=g.indexArray(t);let n=0;for(let l=0;l<t;++l){const c=Math.floor(Math.random()*(t-l));s.push(e[c]),n=e[c],e[c]=e[t-l-1],e[t-l-1]=n}return s}}class Y{constructor(){Object.getOwnPropertyNames(this.constructor.prototype).filter(t=>t!=="constructor").forEach(t=>{this[t]=this[t].bind(this)})}funcs(){return Object.getOwnPropertyNames(this).filter(t=>typeof this[t]=="function")}objs(){return this.props().filter(t=>typeof this[t]=="object")}props(){return Object.getOwnPropertyNames(this).filter(t=>!this.funcs().includes(t))}vals(){return this.props().filter(t=>typeof this[t]!="object")}}const R=class R extends Y{static exclude(t,s){return s.filter(e=>!e.equals(t))}static highestCardInSubset(t){return t.toSorted((s,e)=>e.value()-s.value())[0]}static highestCardInSubsets(t,s){if(t.length===0||s.length===0)return null;const e=R.highestCardInSubset(t),n=R.highestCardInSubset(s);return e.equals(n)?R.highestCardInSubsets(R.exclude(e,t),R.exclude(n,s)):R.max(e,n)}static fromJSON(t){return new R(t.suit,t.rank)}static fromString(t){const s=g.invertMap(R.Ranks),e=g.invertMap(R.Suits);return new R(s[t[0]],e[t[1]])}static includes(t,s){return t.map(e=>e.toString()).includes(s.toString())}static isHighCardLess(t,s){if(t.length===0||s.length===0)return!1;const e=R.highestCardInSubset(t),n=R.highestCardInSubset(s);return e.lt(n)?!0:n.lt(e)?!1:R.isHighCardLess(R.exclude(e,t),R.exclude(n,s))}static max(t,s){return t.lt(s)?s:t}static min(t,s){return t.lt(s)?t:s}constructor(t,s){super(),this.suit=t,this.rank=s}equals(t){return this.value()===t.value()}gt(t){return this.value()>t.value()}isSameAsCard(t){return this.equals(t)&&this.suit===t.suit}lowValue(){return R.LowValues[this.rank]}lt(t){return this.value()<t.value()}toJSON(){return{suit:this.suit,rank:this.rank}}toString(){return`${R.SuitStrings[this.suit]}${R.RankStrings[this.rank]}`}value(){return R.Values[this.rank]}};u(R,"LowValues",{deuce:2,trey:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10,jack:11,queen:12,king:13,ace:1}),u(R,"Ranks",{deuce:"deuce",trey:"trey",four:"four",five:"five",six:"six",seven:"seven",eight:"eight",nine:"nine",ten:"ten",jack:"jack",queen:"queen",king:"king",ace:"ace"}),u(R,"RankStrings",{deuce:"2",trey:"3",four:"4",five:"5",six:"6",seven:"7",eight:"8",nine:"9",ten:"10",jack:"J",queen:"Q",king:"K",ace:"A"}),u(R,"Suits",{club:"club",diamond:"diamond",heart:"heart",spade:"spade"}),u(R,"SuitStrings",{club:"♣️",diamond:"♦️",heart:"♥️",spade:"♠️"}),u(R,"Values",{deuce:2,trey:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10,jack:11,queen:12,king:13,ace:14});let a=R;const d=class d extends Y{static freshCards(){const t=[];for(const s of d.suits)for(const e of d.ranks)t.push(new a(s,e));return t}static fromJSON(t){const s=t[d.KEY_POKER_DECK],e=new d(!1,s[d.KEY_POKER_DECK_DEALT_CARDS].map(n=>a.fromJSON(n)),s[d.KEY_POKER_DECK_DISCARDS].map(n=>a.fromJSON(n)));return e.cards=s[d.KEY_POKER_DECK_CARDS].map(n=>a.fromJSON(n)),e.deckIndex=s[d.KEY_POKER_DECK_INDEX],e}constructor(t=!1,s=[],e=[]){super(),this.cards=d.freshCards(),t?this.shuffle():this.setup(s,e)}burn(t=1){if(this.deckIndex+t>this.cards.length)return null;const s=[];for(let e=1;e<=t;++e){const n=this.cards[this.deckIndex];this.discards.push(n),s.push(n),this.deckIndex+=1}return s}currentCard(){return this.deckIndex<this.cards.length?this.cards[this.deckIndex]:null}dealCard(){if(this.deckIndex+1>this.cards.count)return null;const t=this.cards[this.deckIndex];return this.dealtCards.push(t),this.deckIndex+=1,t}setup(t=[],s=[]){this.dealtCards=t,this.discards=s,this.deckIndex=this.dealtCards.length+this.discards.length}shuffle(){const t=g.randomIndicesForArrayOfSize(this.cards.length),s=[];for(let e=0;e<this.cards.length;++e)s.push(this.cards[t[e]]);this.cards=s,this.setup()}toJSON(){const t={};t[d.KEY_POKER_DECK]={};const s=t[d.KEY_POKER_DECK];return s[d.KEY_POKER_DECK_CARDS]=this.cards.map(e=>e.toJSON()),s[d.KEY_POKER_DECK_DEALT_CARDS]=this.dealtCards.map(e=>e.toJSON()),s[d.KEY_POKER_DECK_DISCARDS]=this.discards.map(e=>e.toJSON()),s[d.KEY_POKER_DECK_INDEX]=this.deckIndex,t}toString(){return`${this.cards}`}};u(d,"ranks",Object.keys(a.Ranks)),u(d,"suits",Object.keys(a.Suits)),u(d,"KEY_POKER_DECK","deck"),u(d,"KEY_POKER_DECK_CARDS",`${d.KEY_POKER_DECK}.cards`),u(d,"KEY_POKER_DECK_DEALT_CARDS",`${d.KEY_POKER_DECK}.dealtCards`),u(d,"KEY_POKER_DECK_DISCARDS",`${d.KEY_POKER_DECK}.discards`),u(d,"KEY_POKER_DECK_INDEX",`${d.KEY_POKER_DECK}.deckIndex`);let y=d;const o=class o extends Y{static cardsInRankOrder(t,s=!1){const e=s?"lowValue":"value";return t.toSorted((n,l)=>n[e]()-l[e]())}static kicker(t,s){const e=t.handRank,n=s.handRank;if(e!==n||t.equals(s))return null;const l=o.max(t,s),c=o.min(t,s);return e===o.Ranks.fourOfAKind?l.cardsGroupedByRank[1][0]:e===o.Ranks.threeOfAKind||e===o.Ranks.pair?t.cardsGroupedByRank[0][0].equals(s.cardsGroupedByRank[0][0])?a.highestCardInSubsets(l.cards.filter(p=>!a.includes(l.cardsGroupedByRank[0],p)),c.cards.filter(p=>!a.includes(c.cardsGroupedByRank[0],p))):null:e===o.Ranks.twoPair&&t.cardsGroupedByRank[1][0].equals(s.cardsGroupedByRank[1][0])&&t.cardsGroupedByRank[0][0].equals(s.cardsGroupedByRank[0][0])?l.cardsGroupedByRank[2][0]:null}static kickersAgainstHands(t,s){const e=s.map(n=>a.kicker(t,n)).filter(n=>n).map(n=>n.toString());return Array.from(new Set(e)).map(n=>a.fromString(n))}static kickersDesc(t){if(!t.length)return"";let s="";for(let e=0;e<t.length-1;++e)s+=`${t[e].rank}, `;return s+`${t[t.length-1].rank} Kicker${t.length>1?"s":""}`}static max(t,s){return t.lt(s)?s:t}static min(t,s){return t.lt(s)?t:s}constructor(t){if(super(),t.length!==5)throw new Error(`Must supply 5 cards (num cards = ${t.length})`);this.cards=t,this.highestCard=a.highestCardInSubset(t),this.cardsGroupedByRank=this.groupByRank(t),this.handRank=this.getHandRank()}cardsString(){return this.cards.map(t=>t.toString())}description(t=!0,s=!1){const e=this;function n(c){return c?"Straight":`
				Straight to the ${e.isStraightAceLow(!0)?o.cardsInRankOrder(e.cards,!0)[this.cards.length-1]:e.highestCard}
			`}function l(c){if(c)return"Two Pair";const p=this.cardsGroupedByRank[0][0],B=this.cardsGroupedByRank[0][1],S=this.cardsGroupedByRank[1][0],I=this.cardsGroupedByRank[1][1];return p.rank===a.Ranks.eight&&S.rank===a.Ranks.ace&&(p.suit===a.Suits.club&&B.suit===a.Suits.spade||p.suit===a.Suits.spade&&B.suit===a.Suits.club)&&(S.suit===a.Suits.club&&I.suit===a.Suits.spade||S.suit===a.Suits.spade&&I.suit===a.Suits.club)?"Dead Man's Hand":`${S.rank.rawValue}s and ${p.rank.rawValue}s`}return this.handRank===o.Ranks.royalFlush?"Royal Flush!":this.handRank===o.Ranks.straightFlush?"Straight Flush"+s?"":` to the ${this.highestCard}`:this.handRank===o.Ranks.fourOfAKind?`Four ${this.cardsGroupedByRank[0][0].rank}s`:this.handRank===o.Ranks.fullHouse?"Full House"+s?"":` ${this.cardsGroupedByRank[0][0].rank}s over ${this.cardsGroupedByRank[1][0].rank}s`:this.handRank===o.Ranks.flush?`${t&&!s?this.cards[0].suit+" ":""}Flush`:this.handRank===o.Ranks.straight?n(s):this.handRank===o.Ranks.threeOfAKind?`Trip ${this.cardsGroupedByRank[0][0].rank}s`:this.handRank===o.Ranks.twoPair?l(s):this.handRank===o.Ranks.pair?`Pair of ${this.cardsGroupedByRank[0][0].rank}s`:`${this.highestCard} High`}getHandRank(){const t={highCard:0,pair:1,twoPair:2,threeOfAKind:3,royalFlush:9,straightFlush:8,straight:4,flush:5,fullHouse:6,fourOfAKind:7};for(const s of Object.keys(t)){const e=`is${g.capitalize(s)}`;if(this[e]&&this[e]())return t[s]}return t.highCard}groupByRank(t){const s=[];let e,n=[];for(const l of o.cardsInRankOrder(t))e&&l.gt(e)&&(s.push(n),n=[]),n.push(l),e=l;return s.push(n),s.sort((l,c)=>c.length-l.length),s}equals(t){if(this.handRank!==t.handRank)return!1;const s=this.handRank,e=this.cardsGroupedByRank;return s===o.Ranks.royalFlush?!0:s===o.Ranks.straightFlush?this.highestCard===t.highestCard:s===o.Ranks.fourOfAKind||s===o.Ranks.fullHouse?e[0][0]===t.cardsGroupedByRank[0][0]&&e[1][0]===t.cardsGroupedByRank[1][0]:s===o.Ranks.flush?a.isHighCardLess(this.cards,t.cards):s===o.Ranks.straight?this.highestCard=t.highestCard:s===o.Ranks.threeOfAKind||s===o.Ranks.twoPair?e[0][0]===t.cardsGroupedByRank[0][0]&&e[1][0]===t.cardsGroupedByRank[1][0]&&e[2][0]===t.cardsGroupedByRank[2][0]:s===o.Ranks.pair?e[0][0]!==t.cardsGroupedByRank[0][0]?!1:!a.isHighCardLess(this.cards.filter(n=>!a.includes(e[0],n)),t.cards.filter(n=>!a.includes(t.cardsGroupedByRank[0],n)))&&!a.isHighCardLess(t.cards.filter(n=>!a.includes(t.cardsGroupedByRank[0],n)),this.cards.filter(n=>!a.includes(e[0],n))):s===o.Ranks.highCard?!a.isHighCardLess(this.cards,t.cards):!1}gt(t){return!this.equals(t)&&!this.lt(t)}isFlush(){return this.cards.every(t=>t.suit===this.cards[0].suit)}isFourOfAKind(){return this.cardsGroupedByRank[0].length===4}isFullHouse(){return this.cardsGroupedByRank[0].length===3&&this.cardsGroupedByRank[1].length===2}isPair(){return this.cardsGroupedByRank[0].length===2&&this.cardsGroupedByRank[1].length===1}isRoyalFlush(){return this.isStraightFlush()&&this.highestCard.rank===a.Ranks.ace}isStraight(){return this.isStraightAceLow()?!0:this.isStraightAceLow(!0)}isStraightAceLow(t=!1){const s=t?"lowValue":"value";let e=o.cardsInRankOrder(this.cards,t),n=e[0];for(let l=1;l<e.length;++l){const c=e[l];if(c[s]()!==n[s]()+1)return!1;n=c}return!0}isStraightFlush(){return this.isStraight()&&this.isFlush()}isThreeOfAKind(){return this.cardsGroupedByRank[0].length===3&&this.cardsGroupedByRank[1].length===1}isTwoPair(){return this.cardsGroupedByRank[0].length===2&&this.cardsGroupedByRank[1].length===2}lt(t){if(this.handRank>=o.Ranks.royalFlush)return!1;if(this.handRank<t.handRank)return!0;if(this.handRank>t.handRank)return!1;const s=this.handRank,e=this.cardsGroupedByRank;if(s===o.Ranks.straightFlush)return this.highestCard.lt(t.highestCard);if(s===o.Ranks.fourOfAKind||s===o.Ranks.fullHouse)return e[0][0].lt(t.cardsGroupedByRank[0][0])?!0:e[0][0].equals(t.cardsGroupedByRank[0][0])?e[1][0].lt(t.cardsGroupedByRank[1][0]):!1;if(s===o.Ranks.flush)return a.isHighCardLess(this.cards,t.cards);if(s===o.Ranks.straight)return this.isStraightAceLow()&&t.isStraightAceLow()||this.isStraightAceLow(!0)&&t.isStraightAceLow(!0)?this.highestCard.lt(t.highestCard):this.isStraightAceLow(!0);if(s===o.Ranks.threeOfAKind)return e[0][0].lt(t.cardsGroupedByRank[0][0])?!0:e[0][0].equals(t.cardsGroupedByRank[0][0])?a.isHighCardLess(this.cards.filter(n=>!a.includes(e[0],n)),t.cards.filter(n=>!a.includes(t.cardsGroupedByRank[0],n))):!1;if(s===o.Ranks.twoPair){if(e[1][0].lt(t.cardsGroupedByRank[1][0]))return!0;if(e[1][0].equals(t.cardsGroupedByRank[1][0])){if(e[0][0].lt(t.cardsGroupedByRank[0][0]))return!0;if(e[0][0].equals(t.cardsGroupedByRank[0][0]))return e[2][0].lt(t.cardsGroupedByRank[2][0])}return!1}return s===o.Ranks.pair?e[0][0].lt(t.cardsGroupedByRank[0][0])?!0:e[0][0].equals(t.cardsGroupedByRank[0][0])?a.isHighCardLess(this.cards.filter(n=>!a.includes(e[0],n)),t.cards.filter(n=>!a.includes(t.cardsGroupedByRank[0],n))):!1:s===o.Ranks.highCard?a.isHighCardLess(this.cards,t.cards):!1}pertinentCards(){return this.isRoyalFlush()||this.isStraightFlush()||this.isStraight()||this.isFullHouse()||this.isFlush()?this.cards:this.isFourOfAKind()||this.isThreeOfAKind()||this.isPair()?this.cardsGroupedByRank[0]:this.isTwoPair()?this.cardsGroupedByRank[0].concat(this.cardsGroupedByRank[1]):this.highestCard}ranksInHand(){const t={};Object.keys(a.Ranks).forEach(s=>{t[s]=0});for(let s of this.cards)t[s.rank]=t[s.rank]+1;return t}suitsInHand(){const t={};Object.keys(a.Suits).forEach(s=>{t[s]=0});for(const s of this.cards)t[s.suit]=t[s.suit]+1;return t}toJSON(){return{cards:this.cards.map(t=>t.toJSON())}}toString(){return`${this.cards}`}};u(o,"lowestHand",new o([new a(a.Suits.club,a.Ranks.seven),new a(a.Suits.diamond,a.Ranks.five),new a(a.Suits.heart,a.Ranks.four),new a(a.Suits.spade,a.Ranks.trey),new a(a.Suits.club,a.Ranks.deuce)])),u(o,"highestHand",new o([new a(a.Suits.spade,a.Ranks.ten),new a(a.Suits.spade,a.Ranks.jack),new a(a.Suits.spade,a.Ranks.queen),new a(a.Suits.spade,a.Ranks.king),new a(a.Suits.spade,a.Ranks.ace)])),u(o,"Ranks",{highCard:0,pair:1,twoPair:2,threeOfAKind:3,straight:4,flush:5,fullHouse:6,fourOfAKind:7,straightFlush:8,royalFlush:9}),u(o,"COMBO_INDICES",[[[0,1,2]],[[0,1,2,3],[0,1,2],[0,2,3],[0,1,3],[1,2,3]],[[0,1,2,3,4],[0,1,2,3],[0,1,2,4],[0,1,3,4],[0,2,3,4],[2,3,4,1],[1,2,3,4],[0,1,2],[0,1,3],[0,1,4],[0,2,3],[0,2,4],[0,3,4],[1,2,3],[1,2,4],[1,3,4],[2,3,4]]]);let K=o;const r=class r extends Y{static isBettingAction(t){return t===r.RoundActions.smallBlind||t===r.RoundActions.bigBlind||t===r.RoundActions.bet||t===r.RoundActions.call||t===r.RoundActions.raise}static fromJSON(t){const s=t[r.KEY_PLAYER],e=new r(s[r.KEY_PLAYER_ID]);return e.isAssigned=s[r.KEY_PLAYER_IS_ASSIGNED],e.stake=s[r.KEY_PLAYER_STAKE],e.wentAllInPreviousRound=s[r.KEY_PLAYER_ALREADY_ALL_IN],e.gameState=s[r.KEY_PLAYER_GAME_STATE],e.handState=s[r.KEY_PLAYER_HAND_STATE],e.hasButton=s[r.KEY_PLAYER_HAS_BUTTON],e.isSmallBlind=s[r.KEY_PLAYER_IS_SMALL_BLIND],e.isBigBlind=s[r.KEY_PLAYER_IS_BIG_BLIND],e.position=s[r.KEY_PLAYER_POSITION],e.pokerFace=s[r.KEY_PLAYER_POKER_FACE],e.currentCards=s[r.KEY_PLAYER_CARDS].map(n=>a.fromJSON(n)),e.lastAction=s[r.KEY_PLAYER_LAST_ACTION],e.currentBets=s[r.KEY_PLAYER_CURRENT_BETS],e.currentBet=s[r.KEY_PLAYER_CURRENT_BET],e.lastBetInRound=s[r.KEY_PLAYER_LAST_BET],e.totalBetsInPotsInRound=s[r.KEY_PLAYER_TOTAL_BETS],e.totalBetsInHand=s[r.KEY_PLAYER_TOTAL_BET_HAND],e.totalBetsInPotsInHand=s[r.KEY_PLAYER_TOTAL_BETS_HAND],e}static getPokerFace(t=null){return t===null?r.PokerFaces.none:r.ValidFaces[t%r.ValidFaces.length]}static buildPlayerArray(t,s=!1){if(t<=0)return[];const e=[];for(let n=0;n<t;++n){const l=new r;s&&(l.pokerFace=self.getPokerFace(n)),e.push(l)}return e}constructor(t=null){super(),this.playerID=t||crypto.randomUUID(),this.isAssigned=!1,this.pokerFace=r.PokerFaces.none,this.stake=r.STARTING_STAKE,this.wentAllInPreviousRound=!1,this.gameState=r.PlayerGameStates.none,this.handState=r.PlayerHandStates.none,this.position=NaN,this.hasButton=!1,this.isSmallBlind=!1,this.isBigBlind=!1,this.currentCards=[],this.currentHand=[],this.currentBets=[0],this.totalBetsInPotsInRound=[0],this.totalBetsInHand=0,this.totalBetsInPotsInHand=[0],this.currentBet=0,this.lastBetInRound=0,this.lastAction=r.RoundActions.none,this.bestHandString=""}totalBetsInRound(){return this.totalBetsInPotsInRound.reduce((t,s)=>t+s,0)}equals(t){return this.playerID===p2.playerID}toJSON(){const t={},s=`${r.KEY_PLAYER}`;t[s]={};const e=t[s];return e[r.KEY_PLAYER_ID]=this.playerID,e[r.KEY_PLAYER_IS_ASSIGNED]=this.isAssigned,e[r.KEY_PLAYER_STAKE]=this.stake,e[r.KEY_PLAYER_ALREADY_ALL_IN]=this.wentAllInPreviousRound,e[r.KEY_PLAYER_GAME_STATE]=this.gameState,e[r.KEY_PLAYER_HAND_STATE]=this.handState,e[r.KEY_PLAYER_HAS_BUTTON]=this.hasButton,e[r.KEY_PLAYER_IS_SMALL_BLIND]=this.isSmallBlind,e[r.KEY_PLAYER_IS_BIG_BLIND]=this.isBigBlind,e[r.KEY_PLAYER_POSITION]=this.position,e[r.KEY_PLAYER_POKER_FACE]=this.pokerFace,e[r.KEY_PLAYER_CARDS]=this.currentCards.map(n=>n.toJSON()),e[r.KEY_PLAYER_LAST_ACTION]=this.lastAction,e[r.KEY_PLAYER_CURRENT_BETS]=this.currentBets,e[r.KEY_PLAYER_CURRENT_BET]=this.currentBet,e[r.KEY_PLAYER_LAST_BET]=this.lastBetInRound,e[r.KEY_PLAYER_TOTAL_BET]=this.totalBetsInRound(),e[r.KEY_PLAYER_TOTAL_BETS]=this.totalBetsInPotsInRound,e[r.KEY_PLAYER_TOTAL_BET_HAND]=this.totalBetsInHand,e[r.KEY_PLAYER_TOTAL_BETS_HAND]=this.totalBetsInPotsInHand,t}};u(r,"PlayerHandStates",{none:0,playing:1,folded:2,winner:3}),u(r,"PlayerGameStates",{none:0,invitedNotAccepted:1,alive:2,busted:3,invitedRejected:4,winner:5}),u(r,"RoundActions",{none:"",smallBlind:"Small",bigBlind:"Big",bet:"Bet",call:"Call",raise:"Raise",check:"Check",fold:"Fold"}),u(r,"ValidActions",[r.RoundActions.none,r.RoundActions.bet,r.RoundActions.call,r.RoundActions.raise,r.RoundActions.check,r.RoundActions.fold]),u(r,"PokerFaces",{none:"😶",cool:"😎",kiss:"😙",smile:"😀",greed:"🤑",wink:"😜",love:"😍",hmm:"🤔",poop:"💩"}),u(r,"ValidFaces",[r.PokerFaces.cool,r.PokerFaces.kiss,r.PokerFaces.smile,r.PokerFaces.greed,r.PokerFaces.wink,r.PokerFaces.love,r.PokerFaces.hmm,r.PokerFaces.poop]),u(r,"STARTING_STAKE",1e3),u(r,"KEY_PLAYER","player"),u(r,"KEY_PLAYER_IS_ASSIGNED",`${r.KEY_PLAYER}.isAssigned`),u(r,"KEY_PLAYER_STAKE",`${r.KEY_PLAYER}.stake`),u(r,"KEY_PLAYER_ALREADY_ALL_IN",`${r.KEY_PLAYER}.alreadyAllIn`),u(r,"KEY_PLAYER_GAME_STATE",`${r.KEY_PLAYER}.gameState`),u(r,"KEY_PLAYER_HAND_STATE",`${r.KEY_PLAYER}.handState`),u(r,"KEY_PLAYER_HAS_BUTTON",`${r.KEY_PLAYER}.hasButton`),u(r,"KEY_PLAYER_IS_SMALL_BLIND",`${r.KEY_PLAYER}.isSmallBlind`),u(r,"KEY_PLAYER_IS_BIG_BLIND",`${r.KEY_PLAYER}.isBigBlind`),u(r,"KEY_PLAYER_POSITION",`${r.KEY_PLAYER}.position`),u(r,"KEY_PLAYER_POKER_FACE",`${r.KEY_PLAYER}.pokerFace`),u(r,"KEY_PLAYER_CARDS",`${r.KEY_PLAYER}.cards`),u(r,"KEY_PLAYER_LAST_ACTION",`${r.KEY_PLAYER}.lastAction`),u(r,"KEY_PLAYER_CURRENT_BET",`${r.KEY_PLAYER}.currentBet`),u(r,"KEY_PLAYER_CURRENT_BETS",`${r.KEY_PLAYER}.currentBets`),u(r,"KEY_PLAYER_LAST_BET",`${r.KEY_PLAYER}.lastBet`),u(r,"KEY_PLAYER_TOTAL_BET",`${r.KEY_PLAYER}.totalBet`),u(r,"KEY_PLAYER_TOTAL_BETS",`${r.KEY_PLAYER}.totalBets`),u(r,"KEY_PLAYER_TOTAL_BET_HAND",`${r.KEY_PLAYER}.totalBetInHand`),u(r,"KEY_PLAYER_TOTAL_BETS_HAND",`${r.KEY_PLAYER}.totalBetsInHand`),u(r,"KEY_PLAYER_ID",`${r.KEY_PLAYER}.playerID`);let E=r;const A=class A extends Y{static fromJSON(t){const s=t[`${A.KEY_POT}`];return new A(s[A.KEY_POT_AMOUNT],s[A.KEY_POT_PLAYERS])}constructor(t=0,s=[]){super(),this.amount=t,this.playersInPot=s}addPlayer(t){this.hasPlayer(t)||this.playersInPot.push(t.playerID)}description(){return`Amount: ${this.amount}; players: ${this.playersInPot}`}hasPlayer(t){return this.playersInPot.includes(t.playerID)}removePlayer(t){this.hasPlayer(t)&&this.playersInPot.splice(this.playersInPot.indexOf(t.playerID),1)}toJSON(){const t={};return t[A.KEY_POT]={},t[A.KEY_POT][A.KEY_POT_AMOUNT]=this.amount,t[A.KEY_POT][A.KEY_POT_PLAYERS]=this.playersInPot,t}};u(A,"KEY_POT","pot"),u(A,"KEY_POT_AMOUNT",`${A.KEY_POT}.amount`),u(A,"KEY_POT_PLAYERS",`${A.KEY_POT}.players`);let O=A;const i=class i extends Y{static nextToken(t){const s=i.GameTokens.indexOf(t||"");return s>=0?i.GameTokens[(s+1)%i.GameTokens.length]:i.GameTokens[0]}static bestHandFromHandAndCards(t,s){return i.bestHandFromCards(t.cards,s)}static bestHandFromCards(t,s){if(t.length<3||t.length>5||s.length!==2)return null;const e=t.length===3?0:t.length===4?1:2;let n,l,c,p;for(const B of K.COMBO_INDICES[e]){p=g.distinctElementsAtPositions(t,B),l=p;const S=5-l.length,I=S===1?1:0;for(let P=0;P<=I;++P){l=p,c=[];for(let m=0;m<S;++m)c.push(s[m+P]);l=l.concat(c);const L=new K(l);(!n||L.gt(n))&&(n=L)}}return n}static fromJSON(t){const s=t[i.KEY_GAME_MODEL],e=s[i.KEY_GAME_PLAYERS].map(l=>E.fromJSON(l)),n=new i(e.length);return n.gameID=s[i.KEY_GAME_ID],n.stateID=s[i.KEY_GAME_STATE_ID],n.authToken=s[i.KEY_GAME_SERVER_AUTH_TOKEN],n.gameToken=s[i.KEY_GAME_TOKEN],n.state=s[i.KEY_GAME_STATE],n.deck=y.fromJSON(s[i.KEY_GAME_DECK]),n.communityCards=s[i.KEY_GAME_COMMUNITY_CARDS].map(l=>a.fromJSON(l)),n.currentPosition=s[i.KEY_GAME_CURRENT_POSITION],n.buttonPosition=s[i.KEY_GAME_BUTTON_POSITION],n.handNumber=s[i.KEY_GAME_ROUND],n.pots=s[i.KEY_GAME_POTS].map(l=>O.fromJSON(l)),n}static initWithPlayers(t){const s=new i(null,0);return s.players=t,s}constructor(t=2){super(),this.gameID=crypto.randomUUID(),this.stateID=crypto.randomUUID(),this.state=i.States.new,this.deck=new y(!0),this.state=i.States.new,this.pots=[],this.communityCards=[],this.players=[],this.buttonPosition=0,this.currentPosition=0,this.handNumber=0;for(let s=1;s<=t;++s)this.players.push(new E);this.state=i.States.ready}allBetsEqual(){let t=this.playersInHandIncludingAllIn().length;if(t<=0)return!0;let e=this.playersInHandIncludingAllIn()[0].totalBetsInRound();for(let n=1;n<t;++n)if(this.playersInHandIncludingAllIn()[n].totalBetsInRound()===e)return!1;return!0}allBetsEqualAfterBettingAround(){for(let t=0;t<this.pots.length;++t){const s=this.pots[t];let e=this.playerWithID(s.playersInPot[0]).totalBetsInPotsInRound[t];for(let n=1;n<this.playersInPots()[t].length;++n)if(this.playersInPots()[t][n].totalBetsInPotsInRound[t]!==e)return!1}return!0}allBetsEqualForPlayersNotAllIn(){const t=this.playersInHand().length;if(t<=0)return!0;const s=this.playersInHand()[0].totalBetsInRound();for(let e=1;e<t;++e)if(this.playersInHand()[e].totalBetsInRound()!==s)return!1;return!0}bestHandForPlayer(t){return i.bestHandFromCards(this.communityCards,t.currentCards)}bigBlind(){return 2*this.smallBlind()}bigBlindPosition(){return(this.buttonPosition+(this.currentPlayers().length>2?2:1))%this.currentPlayers().length}compareBestHandsForPlayers(t,s){const e=this.bestHandForPlayer(t),n=this.bestHandForPlayer(s);return e===null?n!==null:n!==null?e-n:!1}currentPlayers(){return this.players.filter(t=>t.gameState===E.PlayerGameStates.alive||t.gameState===E.PlayerGameStates.busted||t.gameState===E.PlayerGameStates.winner)}didPlayersCheckAround(){return this.playersStillInGame().reduce((t,s)=>s&&t.lastAction===E.RoundActions.check,!0)}goToNextPosition(){this.currentPosition=this.nextPosition()}hasSmallBlindBeenPlayed(){return this.playersStillInGame().reduce((t,s)=>s||t.lastAction===E.RoundActions.smallBlind,!1)}haveAllPlayersActedThisRound(){return this.playersStillInGame().reduce((t,s)=>s&&t.lastAction!==E.RoundActions.none,!0)}haveAnyBetsBeenMadeThisRound(){return this.currentPlayers().reduce((t,s)=>t+s.totalBetsInRound(),0)>0}isBigBlindInGame(){return this.playersStillInGame().reduce((t,s)=>t||s.position===this.bigBlindPosition(),!1)}hasBigBlindBeenPlayed(){return this.playersStillInGame().reduce((t,s)=>t||s.lastAction===E.RoundActions.bigBlind,!1)}isAnyPlayerAllIn(){return this.playersSortedByTotalBetsInRound().reduce((t,s)=>t||s.stake===0,!1)}isComplete(){return i.CompleteStates.includes(this.state)}isEveryPlayerButCurrentAllIn(){return this.playersInHand().filter(t=>t.position!==this.currentPosition).reduce((t,s)=>t&&x.stake===0,!0)}isInProgress(){return i.InProgressStates.includes(this.state)}isInviting(){return i.InvitingStates.includes(this.state)}isRoundOver(){return this.haveAllPlayersActedThisRound()?this.didPlayersCheckAround()||this.allBetsEqual()?!0:this.playersInHandIncludingAllIn().length!==2||this.lastBettingPlayer()===null?this.playersInHand().length===1?this.allBetsEqualAfterBettingAround():this.allBetsEqualForPlayersNotAllIn():!1:!1}lastBettingPlayer(){return this.lastBettingPlayerFromPlayer(this.playerAtCurrentPosition())}lastBettingPlayerFromPlayer(t){let s=t.position,e=s,n=!1,l;const c=this.currentPlayers(),p=c.length;do e=(e+p-1)%p,e!==s?(l=c[e],n=l.lastAction!==E.RoundActions.fold&&l.lastAction!==E.RoundActions.none):n=!0;while(!n);return l}lastPosition(){return(this.currentPosition+this.currentPlayers().length-1)%this.currentPlayers().length}maxBetTotal(){const t=this.playersSortedByTotalBetsInRound();return t[t.length-1].totalBetsInRound()}maxBetTotalInPot(t){const s=this.playersSortedByTotalBetsInRoundAndPot(t);return s[s.length-1].totalBetsInPotsInRound[t]}minBetTotal(){return this.playersSortedByTotalBetsInRound()[0].totalBetsInRound}minimumBet(){return this.pots.reduce((t,s,e)=>t+this.minimumBetInPot(e),0)}minimumBetInPot(t){let s=this.bigBlind();if(!this.isInProgress())return s;if(!this.haveAnyBetsBeenMadeThisRound())return t<this.pots.length-1?0:s;let e=this.maxBetTotalInPot(t);if(e===0&&!E.isBettingAction(this.playerAtCurrentPosition.lastAction)){let n=0;for(let l=t+1;l<this.pots.length;++l)n+=this.minimumBetInPot(l);if(n===0){let l=0;for(let c=0;c<t;++c)l+=this.minimumBetInPot(c);this.isEveryPlayerButCurrentAllIn()||(e=Math.max(this.maxBetTotal(),this.bigBlind())-l)}}else this.isBigBlindInGame()||e<this.bigBlind()&&(this.isAnyPlayerAllIn()||(e=this.bigBlind()));return e-this.playerAtCurrentPosition().totalBetsInPotsInRound[t]}minimumRaise(){let t=Math.max(this.currentPlayers().map(s=>s.currentBet));return t>0?2*t:2*this.bigBlind()}nextButtonPosition(){const t=this.buttonPosition;let s=t,e=!1;do s=(s+1)%this.currentPlayers().length,s!==t?e=this.currentPlayers()[s].gameState===E.PlayerGameStates.alive:e=!0;while(!e);this.buttonPosition=s}nextPosition(){const t=this.currentPosition;let s=t,e=!1;do if(s=(s+1)%this.currentPlayers().length,w(this.currentPlayers()),s!==t){const n=this.currentPlayers()[s];e=n.handState===E.PlayerGameStates.playing&&n.stake>0}else e=!0;while(!e);return s}numPlayersLeftToJoin(){return this.playersStillToJoin().length}playerAtCurrentPosition(){return this.currentPlayers()[this.currentPosition]}playerAtLastPosition(){return this.currentPlayers()[this.lastPosition]}playersInPots(){const t=[];for(const s of this.pots)t.push(s.playersInPot.filter(e=>this.playerWithID(e)).map(e=>this.playerWithID(e)));return t}playersInBestHandOrder(){return this.currentPlayers().sort(this.compareBestHandsForPlayers)}playersInHand(){return this.playersInHandIncludingAllIn().filter(t=>t.stake>0)}playersInHandIncludingAllIn(){return this.currentPlayers().filter(t=>t.handState===E.PlayerHandStates.playing&&!t.wentAllInPreviousRound())}playersOutOfGame(){return this.currentPlayers().filter(t=>t.gameState===E.PlayerHandStates.busted)}playersSortedByTotalBetsInRound(){return this.currentPlayers().filter(t=>t.totalBetsInRound()>0).sort((t,s)=>t.totalBetsInRound()-s.totalBetsInRound())}playersSortedByTotalBetsInRoundAndPot(t){return this.playersInPots()[t].filter(s=>s.totalBetsInPotsInRound[t]>0).sort((s,e)=>s.totalBetsInRound()-e.totalBetsInRound())}playersStillInGame(){return this.currentPlayers().filter(t=>t.gameState===E.PlayerHandStates.alive||t.gameState===E.PlayerHandStates.winner)}playersStillInWhoHaveBetThisRound(){return this.playersInHand().filter(t=>t.lastAction!==E.RoundActions.none)}playersStillInWhoHaveBetThisRoundExcluding(t){return this.playersStillInWhoHaveBetThisRound().filter(s=>s!==t)}playersStillToJoin(){return this.players.filter(t=>t.gameState===E.PlayerGameStates.invitedNotAccepted)}playersWhoHaveBetThisRound(){return this.playersInHandIncludingAllIn().filter(t=>E.isBettingAction(t.lastAction))}playerWithID(t){return this.players.filter(s=>s.playerID===t)[0]}positionsStillInHand(){const t=[];for(const s of this.playersInHand())t.push(s.position);return t}potsWithPlayer(t){return this.pots.filter(s=>s.playersInPot.includes(t.playerID))}raisePlus(){return this.minimumRaise()+this.minimumBet()}smallBlind(){return i.SmallBlinds[Math.min(this.handNumber,i.SmallBlinds.length-1)]}smallBlindPositon(){let t=this.currentPlayers().length>2?1:0;return(this.buttonPosition+t)%this.currentPlayers().length}toJSON(){const t=this.pots.map(n=>n.toJSON()),s={};s[`${i.KEY_GAME_MODEL}`]={};const e=s[`${i.KEY_GAME_MODEL}`];return e[`${i.KEY_GAME_ID}`]=this.gameID,e[`${i.KEY_GAME_STATE_ID}`]=this.stateID,e[`${i.KEY_GAME_STATE}`]=this.state,e[`${i.KEY_GAME_DECK}`]=this.deck.toJSON(),e[`${i.KEY_GAME_POTS}`]=t,e[`${i.KEY_GAME_COMMUNITY_CARDS}`]=this.communityCards.map(n=>n.toJSON()),e[`${i.KEY_GAME_PLAYERS}`]=this.players.map(n=>n.toJSON()),e[`${i.KEY_GAME_CURRENT_POSITION}`]=this.currentPosition,e[`${i.KEY_GAME_BUTTON_POSITION}`]=this.buttonPosition,e[`${i.KEY_GAME_ROUND}`]=this.handNumber,s}totalOfallStakesButCurrent(){let t=0;const s=this.currentPosition;let e=0;for(let n=1;n<this.currentPlayers().length;++n)e=(s+n)%this.currentPlayers().length,t+=this.currentPlayers()[e].stake;return t}winningOrSplitPlayers(){if(this.state!==i.States.handOver)return null;const t=this.playersInBestHandOrder(),s=t[this.currentPlayers().length-1],e=this.bestHandForPlayer(s),n=[s];for(let l=0;l<this.currentPlayers().length-1;++l){const c=t[l];this.bestHandForPlayer(c).equals(e)&&n.push(c)}return n}winningOrSplitPlayersInPot(t){if(this.state!==i.States.handOver&&this.state!==i.States.gameOver)return null;let s,e=t.playersInPot.filter(l=>this.playerWithID(l)!=null).map(l=>this.playerWithID(l)).filter(l=>l.handState!==E.PlayerHandStates.folded).sort(this.compareBestHandsForPlayers);const n=e[e.length-1];if(!n)return null;s=[n];for(let l=0;l<e.length-1;++l){const c=e[l];this.bestHandForPlayer(c).equals(this.bestHandForPlayer(n))&&s.push(c)}return s}winningPlayer(){return this.state===i.States.gameOver?this.playersStillInGame().filter(t=>t.gameState===E.PlayerGameStates.winner)[0]:null}};u(i,"Blinds",{small:0,big:1}),u(i,"ChipValues",[1,5,10,25,100]),u(i,"CompleteStates",[i.States.gameOver,i.States.state===i.States.quorumFailedTimeExpired,i.States.state===i.States.gameCanceled]),u(i,"GameTokens",["♣︎♣︎","♣︎♦︎","♣︎♥︎","♣︎♠︎","♣︎♧","♣︎♢","♣︎♡","♣︎♤","♦︎♣︎","♦︎♦︎","♦︎♥︎","♦︎♠︎","♦︎♧","♦︎♢","♦︎♡","♦︎♤","♥︎♣︎","♥︎♦︎","♥︎♥︎","♥︎♠︎","♥︎♧","♥︎♢","♥︎♡","♥︎♤","♠︎♣︎","♠︎♦︎","♠︎♥︎","♠︎♠︎","♠︎♧","♠︎♢","♠︎♡","♠︎♤","♧♣︎","♧♦︎","♧♥︎","♧♠︎","♧♧","♧♢","♧♡","♧♤","♢♣︎","♢♦︎","♢♥︎","♢♠︎","♢♧","♢♢","♢♡","♢♤","♡♣︎","♡♦︎","♡♥︎","♡♠︎","♡♧","♡♢","♡♡","♡♤","♤♣︎","♤♦︎","♤♥︎","♤♠︎","♤♧","♤♢","♤♡","♤♤"]),u(i,"InProgressStates",[i.States.quorumReachedTimeExpired,i.States.state===i.States.ready,i.States.state===i.States.preFlop,i.States.state===i.States.preTurn,i.States.state===i.States.preRiver,i.States.state===i.States.finalBets,i.States.state===i.States.handOver]),u(i,"InvitingStates",[i.States.invite,i.States.state===i.States.quorumReachedTimeRemains]),u(i,"States",{none:"none",new:"new",invite:"invite",quorumReachedTimeRemains:"quorumReachedTimeRemains",quorumReachedTimeExpired:"quorumReachedTimeExpired",quorumFailedTimeExpired:"quorumFailedTimeExpired",ready:"ready",preFlop:"preFlop",preTurn:"preTurn",preRiver:"preRiver",finalBets:"finalBets",handOver:"handOver",gameOver:"gameOver",gameCanceled:"gameCanceled"}),u(i,"SmallBlinds",[5,10,15,20,25,50,75,100,150,200]),u(i,"KEY_GAME_MODEL","game"),u(i,"KEY_GAME_ID",`${i.KEY_GAME_MODEL}.gameID`),u(i,"KEY_GAME_STATE_ID",`${i.KEY_GAME_MODEL}.stateID`),u(i,"KEY_GAME_SERVER_AUTH_TOKEN",`${i.KEY_GAME_MODEL}.authToken`),u(i,"KEY_GAME_STATE",`${i.KEY_GAME_MODEL}.gameState`),u(i,"KEY_GAME_DECK",`${i.KEY_GAME_MODEL}.deck`),u(i,"KEY_GAME_POTS",`${i.KEY_GAME_MODEL}.pots`),u(i,"KEY_GAME_POT",`${i.KEY_GAME_MODEL}.pot`),u(i,"KEY_GAME_COMMUNITY_CARDS",`${i.KEY_GAME_MODEL}.communityCards`),u(i,"KEY_GAME_PLAYERS",`${i.KEY_GAME_MODEL}.players`),u(i,"KEY_GAME_CURRENT_POSITION",`${i.KEY_GAME_MODEL}.currentPosition`),u(i,"KEY_GAME_BUTTON_POSITION",`${i.KEY_GAME_MODEL}.buttonPosition`),u(i,"KEY_GAME_ROUND",`${i.KEY_GAME_MODEL}.round`),u(i,"KEY_GAME_TOKEN",`${i.KEY_GAME_MODEL}.token`);let T=i;const G=({card:f})=>h.jsx(h.Fragment,{children:h.jsx("span",{children:f.toString()})}),F=({deck:f})=>{const t=f||new y;return h.jsx(h.Fragment,{children:h.jsx("p",{children:t.cards.map((s,e)=>h.jsx(G,{card:s},e))})})},C=({player:f,isBot:t=!1})=>{const s=f||new E;return h.jsxs(h.Fragment,{children:[h.jsx("span",{children:s.pokerFace}),h.jsxs("span",{children:["Stake $",s.stake]}),h.jsx("p",{children:s.currentCards.map((e,n)=>h.jsx(G,{card:e},n))}),!t&&h.jsx("button",{children:"Bet"})]})},v=()=>{let[f,t]=k.useState(()=>new y),[s,e]=k.useState(()=>[new E,new E]),[n,l]=k.useState(()=>new T(s.length)),c=0;const p=s.length;n.players=s;const B=()=>{const I=f.dealCard();s[c].currentCards.push(I),c=(c+1)%p},S=()=>{t(new y(!0))};return h.jsxs(h.Fragment,{children:[h.jsx("h1",{children:"Heads Up!"}),h.jsx("div",{children:"bets"}),h.jsx("div",{children:"board"}),h.jsxs("div",{children:[h.jsx(F,{deck:n.deck}),h.jsx("button",{onClick:S,children:"Shuffle"}),h.jsx("button",{onClick:B,children:"Deal"})]}),h.jsx("div",{children:h.jsx(C,{player:s[0],isBot:"true"})}),h.jsx("div",{children:h.jsx(C,{player:s[1]})})]})};M.createRoot(document.getElementById("root")).render(h.jsx(b.StrictMode,{children:h.jsx(v,{})}));
