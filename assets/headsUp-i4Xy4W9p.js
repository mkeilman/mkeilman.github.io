var D=Object.defineProperty;var N=(B,t,s)=>t in B?D(B,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):B[t]=s;var l=(B,t,s)=>N(B,typeof t!="symbol"?t+"":t,s);import{j as E,r as v,c as w,R as M}from"./client-BW4HFQ8H.js";console.log.bind(console);class P{static capitalize(t){return t[0].toUpperCase()+t.slice(1)}static distinctElementsAtPositions(t,s){const e=[];for(const n of s)n>=0&&n<t.length&&e.push(t[n]);return e}static elementsAtPositions(t,s){return t.filter(e=>s.includes(t.indexOf(e)))}static indexArray(t){const s=new Array(t);for(let e=0;e<t;++e)s[e]=e;return s}static invertMap(t){const s=Object.values(t);if(new Set(s).size!==s.length)throw new Error("Map in not onto");const e={};return Object.keys(t).forEach((n,a)=>{e[s[a]]=n}),e}static log(...t){console.log(...t)}static randomIndicesForArrayOfSize(t){const s=[],e=P.indexArray(t);let n=0;for(let a=0;a<t;++a){const m=Math.floor(Math.random()*(t-a));s.push(e[m]),n=e[m],e[m]=e[t-a-1],e[t-a-1]=n}return s}}class Y{static poop(){}constructor(){Object.getOwnPropertyNames(this.constructor.prototype).filter(t=>t!=="constructor").forEach(t=>{this[t]=this[t].bind(this)})}funcs(){return Object.getOwnPropertyNames(this).filter(t=>typeof this[t]=="function")}objs(){return this.props().filter(t=>typeof this[t]=="object")}props(){return Object.getOwnPropertyNames(this).filter(t=>!this.funcs().includes(t))}vals(){return this.props().filter(t=>typeof this[t]!="object")}}const A=class A extends Y{static exclude(t,s){return s.filter(e=>!e.equals(t))}static highestCardInSubset(t){return t.toSorted((s,e)=>e.value()-s.value())[0]}static highestCardInSubsets(t,s){if(t.length===0||s.length===0)return null;const e=A.highestCardInSubset(t),n=A.highestCardInSubset(s);return e.equals(n)?A.highestCardInSubsets(A.exclude(e,t),A.exclude(n,s)):A.max(e,n)}static fromJSON(t){return new A(t.suit,t.rank)}static fromString(t){const s=P.invertMap(A.Ranks),e=P.invertMap(A.Suits);return new A(s[t[0]],e[t[1]])}static includes(t,s){return t.map(e=>e.toString()).includes(s.toString())}static isHighCardLess(t,s){if(t.length===0||s.length===0)return!1;const e=A.highestCardInSubset(t),n=A.highestCardInSubset(s);return e.lt(n)?!0:n.lt(e)?!1:A.isHighCardLess(A.exclude(e,t),A.exclude(n,s))}static max(t,s){return t.lt(s)?s:t}static min(t,s){return t.lt(s)?t:s}constructor(t,s){super(),this.suit=t,this.rank=s}equals(t){return this.value()===t.value()}gt(t){return this.value()>t.value()}isSameAsCard(t){return this.equals(t)&&this.suit===t.suit}lowValue(){return A.LowValues[this.rank]}lt(t){return this.value()<t.value()}toJSON(){return{suit:this.suit,rank:this.rank}}toString(){return`${A.SuitStrings[this.suit]}${A.RankStrings[this.rank]}`}value(){return A.Values[this.rank]}};l(A,"LowValues",{deuce:2,trey:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10,jack:11,queen:12,king:13,ace:1}),l(A,"Ranks",{deuce:"deuce",trey:"trey",four:"four",five:"five",six:"six",seven:"seven",eight:"eight",nine:"nine",ten:"ten",jack:"jack",queen:"queen",king:"king",ace:"ace"}),l(A,"RankStrings",{deuce:"2",trey:"3",four:"4",five:"5",six:"6",seven:"7",eight:"8",nine:"9",ten:"10",jack:"J",queen:"Q",king:"K",ace:"A"}),l(A,"Suits",{club:"club",diamond:"diamond",heart:"heart",spade:"spade"}),l(A,"SuitStrings",{club:"â™£ï¸",diamond:"â™¦ï¸",heart:"â™¥ï¸",spade:"â™ ï¸"}),l(A,"Values",{deuce:2,trey:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10,jack:11,queen:12,king:13,ace:14});let o=A;const R=class R extends Y{static freshCards(){const t=[];for(const s of R.suits)for(const e of R.ranks)t.push(new o(s,e));return t}static fromJSON(t){const s=t[R.KEY_POKER_DECK],e=new R(!1,s[R.KEY_POKER_DECK_DEALT_CARDS].map(n=>o.fromJSON(n)),s[R.KEY_POKER_DECK_DISCARDS].map(n=>o.fromJSON(n)));return e.cards=s[R.KEY_POKER_DECK_CARDS].map(n=>o.fromJSON(n)),e.deckIndex=s[R.KEY_POKER_DECK_INDEX],e}constructor(t=!1,s=[],e=[]){super(),this.cards=R.freshCards(),t?this.shuffle():this.setup(s,e)}burn(t=1){if(this.deckIndex+t>this.cards.length)return null;const s=[];for(let e=1;e<=t;++e){const n=this.cards[this.deckIndex];this.discards.push(n),s.push(n),this.deckIndex+=1}return s}currentCard(){return this.deckIndex<this.cards.length?this.cards[this.deckIndex]:null}dealCard(){if(this.deckIndex+1>this.cards.count)return null;const t=this.cards[this.deckIndex];return this.dealtCards.push(t),this.deckIndex+=1,t}setup(t=[],s=[]){this.dealtCards=t,this.discards=s,this.deckIndex=this.dealtCards.length+this.discards.length}shuffle(){const t=P.randomIndicesForArrayOfSize(this.cards.length),s=[];for(let e=0;e<this.cards.length;++e)s.push(this.cards[t[e]]);this.cards=s,this.setup()}toJSON(){const t={};t[R.KEY_POKER_DECK]={};const s=t[R.KEY_POKER_DECK];return s[R.KEY_POKER_DECK_CARDS]=this.cards.map(e=>e.toJSON()),s[R.KEY_POKER_DECK_DEALT_CARDS]=this.dealtCards.map(e=>e.toJSON()),s[R.KEY_POKER_DECK_DISCARDS]=this.discards.map(e=>e.toJSON()),s[R.KEY_POKER_DECK_INDEX]=this.deckIndex,t}toString(){return`${this.cards}`}};l(R,"ranks",Object.keys(o.Ranks)),l(R,"suits",Object.keys(o.Suits)),l(R,"KEY_POKER_DECK","deck"),l(R,"KEY_POKER_DECK_CARDS",`${R.KEY_POKER_DECK}.cards`),l(R,"KEY_POKER_DECK_DEALT_CARDS",`${R.KEY_POKER_DECK}.dealtCards`),l(R,"KEY_POKER_DECK_DISCARDS",`${R.KEY_POKER_DECK}.discards`),l(R,"KEY_POKER_DECK_INDEX",`${R.KEY_POKER_DECK}.deckIndex`);let K=R;const d=class d extends Y{static cardsInRankOrder(t,s=!1){const e=s?"lowValue":"value";return t.toSorted((n,a)=>n[e]()-a[e]())}static kicker(t,s){const e=t.handRank,n=s.handRank;if(e!==n||t.equals(s))return null;const a=d.max(t,s),m=d.min(t,s);return e===d.Ranks.fourOfAKind?a.cardsGroupedByRank[1][0]:e===d.Ranks.threeOfAKind||e===d.Ranks.pair?t.cardsGroupedByRank[0][0].equals(s.cardsGroupedByRank[0][0])?o.highestCardInSubsets(a.cards.filter(u=>!o.includes(a.cardsGroupedByRank[0],u)),m.cards.filter(u=>!o.includes(m.cardsGroupedByRank[0],u))):null:e===d.Ranks.twoPair&&t.cardsGroupedByRank[1][0].equals(s.cardsGroupedByRank[1][0])&&t.cardsGroupedByRank[0][0].equals(s.cardsGroupedByRank[0][0])?a.cardsGroupedByRank[2][0]:null}static kickersAgainstHands(t,s){const e=s.map(n=>o.kicker(t,n)).filter(n=>n).map(n=>n.toString());return Array.from(new Set(e)).map(n=>o.fromString(n))}static kickersDesc(t){if(!t.length)return"";let s="";for(let e=0;e<t.length-1;++e)s+=`${t[e].rank}, `;return s+`${t[t.length-1].rank} Kicker${t.length>1?"s":""}`}static max(t,s){return t.lt(s)?s:t}static min(t,s){return t.lt(s)?t:s}constructor(t){if(super(),t.length!==5)throw new Error(`Must supply 5 cards (num cards = ${t.length})`);this.cards=t,this.highestCard=o.highestCardInSubset(t),this.cardsGroupedByRank=this.groupByRank(t),this.handRank=this.getHandRank()}cardsString(){return this.cards.map(t=>t.toString())}description(t=!0,s=!1){const e=this;function n(m){return m?"Straight":`
				Straight to the ${e.isStraightAceLow(!0)?d.cardsInRankOrder(e.cards,!0)[this.cards.length-1]:e.highestCard}
			`}function a(m){if(m)return"Two Pair";const u=this.cardsGroupedByRank[0][0],c=this.cardsGroupedByRank[0][1],y=this.cardsGroupedByRank[1][0],g=this.cardsGroupedByRank[1][1];return u.rank===o.Ranks.eight&&y.rank===o.Ranks.ace&&(u.suit===o.Suits.club&&c.suit===o.Suits.spade||u.suit===o.Suits.spade&&c.suit===o.Suits.club)&&(y.suit===o.Suits.club&&g.suit===o.Suits.spade||y.suit===o.Suits.spade&&g.suit===o.Suits.club)?"Dead Man's Hand":`${y.rank.rawValue}s and ${u.rank.rawValue}s`}return this.handRank===d.Ranks.royalFlush?"Royal Flush!":this.handRank===d.Ranks.straightFlush?"Straight Flush"+s?"":` to the ${this.highestCard}`:this.handRank===d.Ranks.fourOfAKind?`Four ${this.cardsGroupedByRank[0][0].rank}s`:this.handRank===d.Ranks.fullHouse?"Full House"+s?"":` ${this.cardsGroupedByRank[0][0].rank}s over ${this.cardsGroupedByRank[1][0].rank}s`:this.handRank===d.Ranks.flush?`${t&&!s?this.cards[0].suit+" ":""}Flush`:this.handRank===d.Ranks.straight?n(s):this.handRank===d.Ranks.threeOfAKind?`Trip ${this.cardsGroupedByRank[0][0].rank}s`:this.handRank===d.Ranks.twoPair?a(s):this.handRank===d.Ranks.pair?`Pair of ${this.cardsGroupedByRank[0][0].rank}s`:`${this.highestCard} High`}getHandRank(){const t={highCard:0,pair:1,twoPair:2,threeOfAKind:3,royalFlush:9,straightFlush:8,straight:4,flush:5,fullHouse:6,fourOfAKind:7};for(const s of Object.keys(t)){const e=`is${P.capitalize(s)}`;if(this[e]&&this[e]())return t[s]}return t.highCard}groupByRank(t){const s=[];let e,n=[];for(const a of d.cardsInRankOrder(t))e&&a.gt(e)&&(s.push(n),n=[]),n.push(a),e=a;return s.push(n),s.sort((a,m)=>m.length-a.length),s}equals(t){if(this.handRank!==t.handRank)return!1;const s=this.handRank,e=this.cardsGroupedByRank;return s===d.Ranks.royalFlush?!0:s===d.Ranks.straightFlush?this.highestCard===t.highestCard:s===d.Ranks.fourOfAKind||s===d.Ranks.fullHouse?e[0][0]===t.cardsGroupedByRank[0][0]&&e[1][0]===t.cardsGroupedByRank[1][0]:s===d.Ranks.flush?o.isHighCardLess(this.cards,t.cards):s===d.Ranks.straight?this.highestCard=t.highestCard:s===d.Ranks.threeOfAKind||s===d.Ranks.twoPair?e[0][0]===t.cardsGroupedByRank[0][0]&&e[1][0]===t.cardsGroupedByRank[1][0]&&e[2][0]===t.cardsGroupedByRank[2][0]:s===d.Ranks.pair?e[0][0]!==t.cardsGroupedByRank[0][0]?!1:!o.isHighCardLess(this.cards.filter(n=>!o.includes(e[0],n)),t.cards.filter(n=>!o.includes(t.cardsGroupedByRank[0],n)))&&!o.isHighCardLess(t.cards.filter(n=>!o.includes(t.cardsGroupedByRank[0],n)),this.cards.filter(n=>!o.includes(e[0],n))):s===d.Ranks.highCard?!o.isHighCardLess(this.cards,t.cards):!1}gt(t){return!this.equals(t)&&!this.lt(t)}isFlush(){return this.cards.every(t=>t.suit===this.cards[0].suit)}isFourOfAKind(){return this.cardsGroupedByRank[0].length===4}isFullHouse(){return this.cardsGroupedByRank[0].length===3&&this.cardsGroupedByRank[1].length===2}isPair(){return this.cardsGroupedByRank[0].length===2&&this.cardsGroupedByRank[1].length===1}isRoyalFlush(){return this.isStraightFlush()&&this.highestCard.rank===o.Ranks.ace}isStraight(){return this.isStraightAceLow()?!0:this.isStraightAceLow(!0)}isStraightAceLow(t=!1){const s=t?"lowValue":"value";let e=d.cardsInRankOrder(this.cards,t),n=e[0];for(let a=1;a<e.length;++a){const m=e[a];if(m[s]()!==n[s]()+1)return!1;n=m}return!0}isStraightFlush(){return this.isStraight()&&this.isFlush()}isThreeOfAKind(){return this.cardsGroupedByRank[0].length===3&&this.cardsGroupedByRank[1].length===1}isTwoPair(){return this.cardsGroupedByRank[0].length===2&&this.cardsGroupedByRank[1].length===2}lt(t){if(this.handRank>=d.Ranks.royalFlush)return!1;if(this.handRank<t.handRank)return!0;if(this.handRank>t.handRank)return!1;const s=this.handRank,e=this.cardsGroupedByRank;if(s===d.Ranks.straightFlush)return this.highestCard.lt(t.highestCard);if(s===d.Ranks.fourOfAKind||s===d.Ranks.fullHouse)return e[0][0].lt(t.cardsGroupedByRank[0][0])?!0:e[0][0].equals(t.cardsGroupedByRank[0][0])?e[1][0].lt(t.cardsGroupedByRank[1][0]):!1;if(s===d.Ranks.flush)return o.isHighCardLess(this.cards,t.cards);if(s===d.Ranks.straight)return this.isStraightAceLow()&&t.isStraightAceLow()||this.isStraightAceLow(!0)&&t.isStraightAceLow(!0)?this.highestCard.lt(t.highestCard):this.isStraightAceLow(!0);if(s===d.Ranks.threeOfAKind)return e[0][0].lt(t.cardsGroupedByRank[0][0])?!0:e[0][0].equals(t.cardsGroupedByRank[0][0])?o.isHighCardLess(this.cards.filter(n=>!o.includes(e[0],n)),t.cards.filter(n=>!o.includes(t.cardsGroupedByRank[0],n))):!1;if(s===d.Ranks.twoPair){if(e[1][0].lt(t.cardsGroupedByRank[1][0]))return!0;if(e[1][0].equals(t.cardsGroupedByRank[1][0])){if(e[0][0].lt(t.cardsGroupedByRank[0][0]))return!0;if(e[0][0].equals(t.cardsGroupedByRank[0][0]))return e[2][0].lt(t.cardsGroupedByRank[2][0])}return!1}return s===d.Ranks.pair?e[0][0].lt(t.cardsGroupedByRank[0][0])?!0:e[0][0].equals(t.cardsGroupedByRank[0][0])?o.isHighCardLess(this.cards.filter(n=>!o.includes(e[0],n)),t.cards.filter(n=>!o.includes(t.cardsGroupedByRank[0],n))):!1:s===d.Ranks.highCard?o.isHighCardLess(this.cards,t.cards):!1}pertinentCards(){return this.isRoyalFlush()||this.isStraightFlush()||this.isStraight()||this.isFullHouse()||this.isFlush()?this.cards:this.isFourOfAKind()||this.isThreeOfAKind()||this.isPair()?this.cardsGroupedByRank[0]:this.isTwoPair()?this.cardsGroupedByRank[0].concat(this.cardsGroupedByRank[1]):this.highestCard}ranksInHand(){const t={};Object.keys(o.Ranks).forEach(s=>{t[s]=0});for(let s of this.cards)t[s.rank]=t[s.rank]+1;return t}suitsInHand(){const t={};Object.keys(o.Suits).forEach(s=>{t[s]=0});for(const s of this.cards)t[s.suit]=t[s.suit]+1;return t}toJSON(){return{cards:this.cards.map(t=>t.toJSON())}}toString(){return`${this.cards}`}};l(d,"lowestHand",new d([new o(o.Suits.club,o.Ranks.seven),new o(o.Suits.diamond,o.Ranks.five),new o(o.Suits.heart,o.Ranks.four),new o(o.Suits.spade,o.Ranks.trey),new o(o.Suits.club,o.Ranks.deuce)])),l(d,"highestHand",new d([new o(o.Suits.spade,o.Ranks.ten),new o(o.Suits.spade,o.Ranks.jack),new o(o.Suits.spade,o.Ranks.queen),new o(o.Suits.spade,o.Ranks.king),new o(o.Suits.spade,o.Ranks.ace)])),l(d,"Ranks",{highCard:0,pair:1,twoPair:2,threeOfAKind:3,straight:4,flush:5,fullHouse:6,fourOfAKind:7,straightFlush:8,royalFlush:9}),l(d,"COMBO_INDICES",[[[0,1,2]],[[0,1,2,3],[0,1,2],[0,2,3],[0,1,3],[1,2,3]],[[0,1,2,3,4],[0,1,2,3],[0,1,2,4],[0,1,3,4],[0,2,3,4],[2,3,4,1],[1,2,3,4],[0,1,2],[0,1,3],[0,1,4],[0,2,3],[0,2,4],[0,3,4],[1,2,3],[1,2,4],[1,3,4],[2,3,4]]]);let O=d;const i=class i extends Y{static isBettingAction(t){return t===i.RoundActions.smallBlind||t===i.RoundActions.bigBlind||t===i.RoundActions.bet||t===i.RoundActions.call||t===i.RoundActions.raise}static buildPlayerArray(t,s=!1){if(t<=0)return[];const e=[];for(let n=0;n<t;++n){const a=new i;s&&(a.pokerFace=self.getPokerFace(n)),e.push(a)}return e}static fromJSON(t){const s=t[i.KEY_PLAYER],e=new i(s[i.KEY_PLAYER_ID]);return e.isAssigned=s[i.KEY_PLAYER_IS_ASSIGNED],e.stake=s[i.KEY_PLAYER_STAKE],e.wentAllInPreviousRound=s[i.KEY_PLAYER_ALREADY_ALL_IN],e.gameState=s[i.KEY_PLAYER_GAME_STATE],e.handState=s[i.KEY_PLAYER_HAND_STATE],e.hasButton=s[i.KEY_PLAYER_HAS_BUTTON],e.isSmallBlind=s[i.KEY_PLAYER_IS_SMALL_BLIND],e.isBigBlind=s[i.KEY_PLAYER_IS_BIG_BLIND],e.position=s[i.KEY_PLAYER_POSITION],e.pokerFace=s[i.KEY_PLAYER_POKER_FACE],e.currentCards=s[i.KEY_PLAYER_CARDS].map(n=>o.fromJSON(n)),e.lastAction=s[i.KEY_PLAYER_LAST_ACTION],e.currentBets=s[i.KEY_PLAYER_CURRENT_BETS],e.currentBet=s[i.KEY_PLAYER_CURRENT_BET],e.lastBetInRound=s[i.KEY_PLAYER_LAST_BET],e.totalBetsInPotsInRound=s[i.KEY_PLAYER_TOTAL_BETS],e.totalBetsInHand=s[i.KEY_PLAYER_TOTAL_BET_HAND],e.totalBetsInPotsInHand=s[i.KEY_PLAYER_TOTAL_BETS_HAND],e}static getPokerFace(t=null){return t===null?i.PokerFaces.none:i.ValidFaces[t%i.ValidFaces.length]}static includes(t,s){return t.map(e=>e.playerID).includes(s.playerID)}constructor(t=null){super(),this.playerID=t||crypto.randomUUID(),this.isAssigned=!1,this.pokerFace=i.PokerFaces.none,this.stake=i.STARTING_STAKE,this.wentAllInPreviousRound=!1,this.gameState=i.PlayerGameStates.none,this.handState=i.PlayerHandStates.none,this.position=NaN,this.hasButton=!1,this.isSmallBlind=!1,this.isBigBlind=!1,this.currentCards=[],this.currentHand=[],this.currentBets=[0],this.totalBetsInPotsInRound=[0],this.totalBetsInHand=0,this.totalBetsInPotsInHand=[0],this.currentBet=0,this.lastBetInRound=0,this.lastAction=i.RoundActions.none,this.bestHandString=""}totalBetsInRound(){return this.totalBetsInPotsInRound.reduce((t,s)=>t+s,0)}equals(t){return this.playerID===p2.playerID}toJSON(){const t={},s=`${i.KEY_PLAYER}`;t[s]={};const e=t[s];return e[i.KEY_PLAYER_ID]=this.playerID,e[i.KEY_PLAYER_IS_ASSIGNED]=this.isAssigned,e[i.KEY_PLAYER_STAKE]=this.stake,e[i.KEY_PLAYER_ALREADY_ALL_IN]=this.wentAllInPreviousRound,e[i.KEY_PLAYER_GAME_STATE]=this.gameState,e[i.KEY_PLAYER_HAND_STATE]=this.handState,e[i.KEY_PLAYER_HAS_BUTTON]=this.hasButton,e[i.KEY_PLAYER_IS_SMALL_BLIND]=this.isSmallBlind,e[i.KEY_PLAYER_IS_BIG_BLIND]=this.isBigBlind,e[i.KEY_PLAYER_POSITION]=this.position,e[i.KEY_PLAYER_POKER_FACE]=this.pokerFace,e[i.KEY_PLAYER_CARDS]=this.currentCards.map(n=>n.toJSON()),e[i.KEY_PLAYER_LAST_ACTION]=this.lastAction,e[i.KEY_PLAYER_CURRENT_BETS]=this.currentBets,e[i.KEY_PLAYER_CURRENT_BET]=this.currentBet,e[i.KEY_PLAYER_LAST_BET]=this.lastBetInRound,e[i.KEY_PLAYER_TOTAL_BET]=this.totalBetsInRound(),e[i.KEY_PLAYER_TOTAL_BETS]=this.totalBetsInPotsInRound,e[i.KEY_PLAYER_TOTAL_BET_HAND]=this.totalBetsInHand,e[i.KEY_PLAYER_TOTAL_BETS_HAND]=this.totalBetsInPotsInHand,t}};l(i,"PlayerHandStates",{none:0,playing:1,folded:2,winner:3}),l(i,"PlayerGameStates",{none:0,invitedNotAccepted:1,alive:2,busted:3,invitedRejected:4,winner:5}),l(i,"RoundActions",{none:"",smallBlind:"Small",bigBlind:"Big",bet:"Bet",call:"Call",raise:"Raise",check:"Check",fold:"Fold"}),l(i,"ValidActions",[i.RoundActions.none,i.RoundActions.bet,i.RoundActions.call,i.RoundActions.raise,i.RoundActions.check,i.RoundActions.fold]),l(i,"PokerFaces",{none:"ðŸ˜¶",cool:"ðŸ˜Ž",kiss:"ðŸ˜™",smile:"ðŸ˜€",greed:"ðŸ¤‘",wink:"ðŸ˜œ",love:"ðŸ˜",hmm:"ðŸ¤”",poop:"ðŸ’©"}),l(i,"ValidFaces",[i.PokerFaces.cool,i.PokerFaces.kiss,i.PokerFaces.smile,i.PokerFaces.greed,i.PokerFaces.wink,i.PokerFaces.love,i.PokerFaces.hmm,i.PokerFaces.poop]),l(i,"STARTING_STAKE",1e3),l(i,"KEY_PLAYER","player"),l(i,"KEY_PLAYER_IS_ASSIGNED",`${i.KEY_PLAYER}.isAssigned`),l(i,"KEY_PLAYER_STAKE",`${i.KEY_PLAYER}.stake`),l(i,"KEY_PLAYER_ALREADY_ALL_IN",`${i.KEY_PLAYER}.alreadyAllIn`),l(i,"KEY_PLAYER_GAME_STATE",`${i.KEY_PLAYER}.gameState`),l(i,"KEY_PLAYER_HAND_STATE",`${i.KEY_PLAYER}.handState`),l(i,"KEY_PLAYER_HAS_BUTTON",`${i.KEY_PLAYER}.hasButton`),l(i,"KEY_PLAYER_IS_SMALL_BLIND",`${i.KEY_PLAYER}.isSmallBlind`),l(i,"KEY_PLAYER_IS_BIG_BLIND",`${i.KEY_PLAYER}.isBigBlind`),l(i,"KEY_PLAYER_POSITION",`${i.KEY_PLAYER}.position`),l(i,"KEY_PLAYER_POKER_FACE",`${i.KEY_PLAYER}.pokerFace`),l(i,"KEY_PLAYER_CARDS",`${i.KEY_PLAYER}.cards`),l(i,"KEY_PLAYER_LAST_ACTION",`${i.KEY_PLAYER}.lastAction`),l(i,"KEY_PLAYER_CURRENT_BET",`${i.KEY_PLAYER}.currentBet`),l(i,"KEY_PLAYER_CURRENT_BETS",`${i.KEY_PLAYER}.currentBets`),l(i,"KEY_PLAYER_LAST_BET",`${i.KEY_PLAYER}.lastBet`),l(i,"KEY_PLAYER_TOTAL_BET",`${i.KEY_PLAYER}.totalBet`),l(i,"KEY_PLAYER_TOTAL_BETS",`${i.KEY_PLAYER}.totalBets`),l(i,"KEY_PLAYER_TOTAL_BET_HAND",`${i.KEY_PLAYER}.totalBetInHand`),l(i,"KEY_PLAYER_TOTAL_BETS_HAND",`${i.KEY_PLAYER}.totalBetsInHand`),l(i,"KEY_PLAYER_ID",`${i.KEY_PLAYER}.playerID`);let f=i;const I=class I extends Y{static fromJSON(t){const s=t[`${I.KEY_POT}`];return new I(s[I.KEY_POT_AMOUNT],s[I.KEY_POT_PLAYERS])}constructor(t=0,s=[]){super(),this.amount=t,this.playersInPot=s}addPlayer(t){this.hasPlayer(t)||this.playersInPot.push(t.playerID)}description(){return`Amount: ${this.amount}; players: ${this.playersInPot}`}hasPlayer(t){return this.playersInPot.includes(t.playerID)}removePlayer(t){this.hasPlayer(t)&&this.playersInPot.splice(this.playersInPot.indexOf(t.playerID),1)}toJSON(){const t={};return t[I.KEY_POT]={},t[I.KEY_POT][I.KEY_POT_AMOUNT]=this.amount,t[I.KEY_POT][I.KEY_POT_PLAYERS]=this.playersInPot,t}};l(I,"KEY_POT","pot"),l(I,"KEY_POT_AMOUNT",`${I.KEY_POT}.amount`),l(I,"KEY_POT_PLAYERS",`${I.KEY_POT}.players`);let k=I;const r=class r extends Y{static nextToken(t){const s=r.GameTokens.indexOf(t||"");return s>=0?r.GameTokens[(s+1)%r.GameTokens.length]:r.GameTokens[0]}static bestHandFromHandAndCards(t,s){return r.bestHandFromCards(t.cards,s)}static bestHandFromCards(t,s){if(t.length<3||t.length>5||s.length!==2)return null;const e=t.length===3?0:t.length===4?1:2;let n,a,m,u;for(const c of O.COMBO_INDICES[e]){u=P.distinctElementsAtPositions(t,c),a=u;const y=5-a.length,g=y===1?1:0;for(let T=0;T<=g;++T){a=u,m=[];for(let L=0;L<y;++L)m.push(s[L+T]);a=a.concat(m);const G=new O(a);(!n||G.gt(n))&&(n=G)}}return n}static fromJSON(t){const s=t[r.KEY_GAME_MODEL],e=s[r.KEY_GAME_PLAYERS].map(a=>f.fromJSON(a)),n=new r(e.length);return n.players=e,n.gameID=s[r.KEY_GAME_ID],n.stateID=s[r.KEY_GAME_STATE_ID],n.authToken=s[r.KEY_GAME_SERVER_AUTH_TOKEN],n.gameToken=s[r.KEY_GAME_TOKEN],n.state=s[r.KEY_GAME_STATE],n.deck=K.fromJSON(s[r.KEY_GAME_DECK]),n.communityCards=s[r.KEY_GAME_COMMUNITY_CARDS].map(a=>o.fromJSON(a)),n.currentPosition=s[r.KEY_GAME_CURRENT_POSITION],n.buttonPosition=s[r.KEY_GAME_BUTTON_POSITION],n.handNumber=s[r.KEY_GAME_ROUND],n.pots=s[r.KEY_GAME_POTS].map(a=>k.fromJSON(a)),n}static initWithPlayers(t){const s=new r(null,0);return s.players=t,s}constructor(t=2){super(),this.gameID=crypto.randomUUID(),this.stateID=crypto.randomUUID(),this.state=r.States.new,this.deck=new K(!0),this.state=r.States.new,this.pots=[new k],this.communityCards=[],this.players=[],this.buttonPosition=0,this.currentPosition=0,this.handNumber=0;for(let s=0;s<t;++s){const e=new f;e.gameState=f.PlayerGameStates.alive,e.position=s,this.players.push(e)}this.state=r.States.ready}allBetsEqual(){let t=this.playersInHandIncludingAllIn().length;if(t<=0)return!0;let e=this.playersInHandIncludingAllIn()[0].totalBetsInRound();for(let n=1;n<t;++n)if(this.playersInHandIncludingAllIn()[n].totalBetsInRound()===e)return!1;return!0}allBetsEqualAfterBettingAround(){for(let t=0;t<this.pots.length;++t){const s=this.pots[t];let e=this.playerWithID(s.playersInPot[0]).totalBetsInPotsInRound[t];for(let n=1;n<this.playersInPots()[t].length;++n)if(this.playersInPots()[t][n].totalBetsInPotsInRound[t]!==e)return!1}return!0}allBetsEqualForPlayersNotAllIn(){const t=this.playersInHand().length;if(t<=0)return!0;const s=this.playersInHand()[0].totalBetsInRound();for(let e=1;e<t;++e)if(this.playersInHand()[e].totalBetsInRound()!==s)return!1;return!0}bestHandForPlayer(t){return r.bestHandFromCards(this.communityCards,t.currentCards)}bigBlind(){return 2*this.smallBlind()}bigBlindPosition(){return(this.buttonPosition+(this.currentPlayers().length>2?2:1))%this.currentPlayers().length}compareBestHandsForPlayers(t,s){const e=this.bestHandForPlayer(t),n=this.bestHandForPlayer(s);return e===null?n!==null:n!==null?e-n:!1}currentPlayers(){return this.players.filter(t=>t.gameState===f.PlayerGameStates.alive||t.gameState===f.PlayerGameStates.busted||t.gameState===f.PlayerGameStates.winner)}didPlayersCheckAround(){return this.playersStillInGame().reduce((t,s)=>s&&t.lastAction===f.RoundActions.check,!0)}goToNextPosition(){this.currentPosition=this.nextPosition()}hasSmallBlindBeenPlayed(){return this.playersStillInGame().reduce((t,s)=>s||t.lastAction===f.RoundActions.smallBlind,!1)}haveAllPlayersActedThisRound(){return this.playersStillInGame().reduce((t,s)=>s&&t.lastAction!==f.RoundActions.none,!0)}haveAnyBetsBeenMadeThisRound(){return this.currentPlayers().reduce((t,s)=>t+s.totalBetsInRound(),0)>0}isBigBlindInGame(){return this.playersStillInGame().reduce((t,s)=>t||s.position===this.bigBlindPosition(),!1)}hasBigBlindBeenPlayed(){return this.playersStillInGame().reduce((t,s)=>t||s.lastAction===f.RoundActions.bigBlind,!1)}isAnyPlayerAllIn(){return this.playersSortedByTotalBetsInRound().reduce((t,s)=>t||s.stake===0,!1)}isComplete(){return r.StatesComplete.includes(this.state)}isEveryPlayerButCurrentAllIn(){return this.playersInHand().filter(t=>t.position!==this.currentPosition).reduce((t,s)=>t&&x.stake===0,!0)}isInProgress(){return r.StatesInProgress.includes(this.state)}isInviting(){return r.StatesInviting.includes(this.state)}isRoundOver(){return this.haveAllPlayersActedThisRound()?this.didPlayersCheckAround()||this.allBetsEqual()?!0:this.playersInHandIncludingAllIn().length!==2||this.lastBettingPlayer()===null?this.playersInHand().length===1?this.allBetsEqualAfterBettingAround():this.allBetsEqualForPlayersNotAllIn():!1:!1}lastBettingPlayer(){return this.lastBettingPlayerFromPlayer(this.playerAtCurrentPosition())}lastBettingPlayerFromPlayer(t){let s=t.position,e=s,n=!1,a;const m=this.currentPlayers(),u=m.length;do e=(e+u-1)%u,e!==s?(a=m[e],n=a.lastAction!==f.RoundActions.fold&&a.lastAction!==f.RoundActions.none):n=!0;while(!n);return a}lastPosition(){return(this.currentPosition+this.currentPlayers().length-1)%this.currentPlayers().length}maxBetTotal(){const t=this.playersSortedByTotalBetsInRound();return t[t.length-1].totalBetsInRound()}maxBetTotalInPot(t){const s=this.playersSortedByTotalBetsInRoundAndPot(t);return s[s.length-1].totalBetsInPotsInRound[t]}minBetTotal(){return this.playersSortedByTotalBetsInRound()[0].totalBetsInRound}minimumBet(){return this.pots.reduce((t,s,e)=>t+this.minimumBetInPot(e),0)}minimumBetInPot(t){let s=this.bigBlind();if(!this.isInProgress())return s;if(!this.haveAnyBetsBeenMadeThisRound())return t<this.pots.length-1?0:s;let e=this.maxBetTotalInPot(t);if(e===0&&!f.isBettingAction(this.playerAtCurrentPosition.lastAction)){let n=0;for(let a=t+1;a<this.pots.length;++a)n+=this.minimumBetInPot(a);if(n===0){let a=0;for(let m=0;m<t;++m)a+=this.minimumBetInPot(m);this.isEveryPlayerButCurrentAllIn()||(e=Math.max(this.maxBetTotal(),this.bigBlind())-a)}}else this.isBigBlindInGame()||e<this.bigBlind()&&(this.isAnyPlayerAllIn()||(e=this.bigBlind()));return e-this.playerAtCurrentPosition().totalBetsInPotsInRound[t]}minimumRaise(){let t=Math.max(this.currentPlayers().map(s=>s.currentBet));return t>0?2*t:2*this.bigBlind()}nextButtonPosition(){const t=this.buttonPosition;let s=t,e=!1;do s=(s+1)%this.currentPlayers().length,s!==t?e=this.currentPlayers()[s].gameState===f.PlayerGameStates.alive:e=!0;while(!e);this.buttonPosition=s}nextPosition(){const t=this.currentPosition;let s=t,e=!1;do if(s=(s+1)%this.currentPlayers().length,s!==t){const n=this.currentPlayers()[s];e=n.handState===f.PlayerGameStates.playing&&n.stake>0}else e=!0;while(!e);return s}numPlayersLeftToJoin(){return this.playersStillToJoin().length}playerAtCurrentPosition(){return this.currentPlayers()[this.currentPosition]}playerAtLastPosition(){return this.currentPlayers()[this.lastPosition]}playersInPots(){const t=[];for(const s of this.pots)t.push(s.playersInPot.filter(e=>this.playerWithID(e)).map(e=>this.playerWithID(e)));return t}playersInBestHandOrder(){return this.currentPlayers().sort(this.compareBestHandsForPlayers)}playersInHand(){return this.playersInHandIncludingAllIn().filter(t=>t.stake>0)}playersInHandIncludingAllIn(){return this.currentPlayers().filter(t=>t.handState===f.PlayerHandStates.playing&&!t.wentAllInPreviousRound)}playersOutOfGame(){return this.currentPlayers().filter(t=>t.gameState===f.PlayerHandStates.busted)}playersSortedByTotalBetsInRound(){return this.currentPlayers().filter(t=>t.totalBetsInRound()>0).sort((t,s)=>t.totalBetsInRound()-s.totalBetsInRound())}playersSortedByTotalBetsInRoundAndPot(t){return this.playersInPots()[t].filter(s=>s.totalBetsInPotsInRound[t]>0).sort((s,e)=>s.totalBetsInRound()-e.totalBetsInRound())}playersStillInGame(){return this.currentPlayers().filter(t=>t.gameState===f.PlayerGameStates.alive||t.gameState===f.PlayerGameStates.winner)}playersStillInWhoHaveBetThisRound(){return this.playersInHand().filter(t=>t.lastAction!==f.RoundActions.none)}playersStillInWhoHaveBetThisRoundExcluding(t){return this.playersStillInWhoHaveBetThisRound().filter(s=>s!==t)}playersStillToJoin(){return this.players.filter(t=>t.gameState===f.PlayerGameStates.invitedNotAccepted)}playersWhoHaveBetThisRound(){return this.playersInHandIncludingAllIn().filter(t=>f.isBettingAction(t.lastAction))}playerWithID(t){return this.players.filter(s=>s.playerID===t)[0]}positionsStillInHand(){const t=[];for(const s of this.playersInHand())t.push(s.position);return t}potsWithPlayer(t){return this.pots.filter(s=>s.playersInPot.includes(t.playerID))}raisePlus(){return this.minimumRaise()+this.minimumBet()}smallBlind(){return r.SmallBlinds[Math.min(this.handNumber,r.SmallBlinds.length-1)]}smallBlindPositon(){let t=this.currentPlayers().length>2?1:0;return(this.buttonPosition+t)%this.currentPlayers().length}toJSON(){const t=this.pots.map(n=>n.toJSON()),s={};s[`${r.KEY_GAME_MODEL}`]={};const e=s[`${r.KEY_GAME_MODEL}`];return e[`${r.KEY_GAME_ID}`]=this.gameID,e[`${r.KEY_GAME_STATE_ID}`]=this.stateID,e[`${r.KEY_GAME_STATE}`]=this.state,e[`${r.KEY_GAME_DECK}`]=this.deck.toJSON(),e[`${r.KEY_GAME_POTS}`]=t,e[`${r.KEY_GAME_COMMUNITY_CARDS}`]=this.communityCards.map(n=>n.toJSON()),e[`${r.KEY_GAME_PLAYERS}`]=this.players.map(n=>n.toJSON()),e[`${r.KEY_GAME_CURRENT_POSITION}`]=this.currentPosition,e[`${r.KEY_GAME_BUTTON_POSITION}`]=this.buttonPosition,e[`${r.KEY_GAME_ROUND}`]=this.handNumber,s}totalOfallStakesButCurrent(){let t=0;const s=this.currentPosition;let e=0;for(let n=1;n<this.currentPlayers().length;++n)e=(s+n)%this.currentPlayers().length,t+=this.currentPlayers()[e].stake;return t}winningOrSplitPlayers(){if(this.state!==r.States.handOver)return null;const t=this.playersInBestHandOrder(),s=t[this.currentPlayers().length-1],e=this.bestHandForPlayer(s),n=[s];for(let a=0;a<this.currentPlayers().length-1;++a){const m=t[a];this.bestHandForPlayer(m).equals(e)&&n.push(m)}return n}winningOrSplitPlayersInPot(t){if(this.state!==r.States.handOver&&this.state!==r.States.gameOver)return null;let s,e=t.playersInPot.filter(a=>this.playerWithID(a)!=null).map(a=>this.playerWithID(a)).filter(a=>a.handState!==f.PlayerHandStates.folded).sort(this.compareBestHandsForPlayers);const n=e[e.length-1];if(!n)return null;s=[n];for(let a=0;a<e.length-1;++a){const m=e[a];this.bestHandForPlayer(m).equals(this.bestHandForPlayer(n))&&s.push(m)}return s}winningPlayer(){return this.state===r.States.gameOver?this.playersStillInGame().filter(t=>t.gameState===f.PlayerGameStates.winner)[0]:null}};l(r,"Blinds",{small:0,big:1}),l(r,"ChipValues",[1,5,10,25,100]),l(r,"GameTokens",["â™£ï¸Žâ™£ï¸Ž","â™£ï¸Žâ™¦ï¸Ž","â™£ï¸Žâ™¥ï¸Ž","â™£ï¸Žâ™ ï¸Ž","â™£ï¸Žâ™§","â™£ï¸Žâ™¢","â™£ï¸Žâ™¡","â™£ï¸Žâ™¤","â™¦ï¸Žâ™£ï¸Ž","â™¦ï¸Žâ™¦ï¸Ž","â™¦ï¸Žâ™¥ï¸Ž","â™¦ï¸Žâ™ ï¸Ž","â™¦ï¸Žâ™§","â™¦ï¸Žâ™¢","â™¦ï¸Žâ™¡","â™¦ï¸Žâ™¤","â™¥ï¸Žâ™£ï¸Ž","â™¥ï¸Žâ™¦ï¸Ž","â™¥ï¸Žâ™¥ï¸Ž","â™¥ï¸Žâ™ ï¸Ž","â™¥ï¸Žâ™§","â™¥ï¸Žâ™¢","â™¥ï¸Žâ™¡","â™¥ï¸Žâ™¤","â™ ï¸Žâ™£ï¸Ž","â™ ï¸Žâ™¦ï¸Ž","â™ ï¸Žâ™¥ï¸Ž","â™ ï¸Žâ™ ï¸Ž","â™ ï¸Žâ™§","â™ ï¸Žâ™¢","â™ ï¸Žâ™¡","â™ ï¸Žâ™¤","â™§â™£ï¸Ž","â™§â™¦ï¸Ž","â™§â™¥ï¸Ž","â™§â™ ï¸Ž","â™§â™§","â™§â™¢","â™§â™¡","â™§â™¤","â™¢â™£ï¸Ž","â™¢â™¦ï¸Ž","â™¢â™¥ï¸Ž","â™¢â™ ï¸Ž","â™¢â™§","â™¢â™¢","â™¢â™¡","â™¢â™¤","â™¡â™£ï¸Ž","â™¡â™¦ï¸Ž","â™¡â™¥ï¸Ž","â™¡â™ ï¸Ž","â™¡â™§","â™¡â™¢","â™¡â™¡","â™¡â™¤","â™¤â™£ï¸Ž","â™¤â™¦ï¸Ž","â™¤â™¥ï¸Ž","â™¤â™ ï¸Ž","â™¤â™§","â™¤â™¢","â™¤â™¡","â™¤â™¤"]),l(r,"States",{none:"none",new:"new",invite:"invite",quorumReachedTimeRemains:"quorumReachedTimeRemains",quorumReachedTimeExpired:"quorumReachedTimeExpired",quorumFailedTimeExpired:"quorumFailedTimeExpired",ready:"ready",preFlop:"preFlop",preTurn:"preTurn",preRiver:"preRiver",finalBets:"finalBets",handOver:"handOver",gameOver:"gameOver",gameCanceled:"gameCanceled"}),l(r,"StatesComplete",[r.States.gameOver,r.States.state===r.States.quorumFailedTimeExpired,r.States.state===r.States.gameCanceled]),l(r,"StatesInProgress",[r.States.quorumReachedTimeExpired,r.States.state===r.States.ready,r.States.state===r.States.preFlop,r.States.state===r.States.preTurn,r.States.state===r.States.preRiver,r.States.state===r.States.finalBets,r.States.state===r.States.handOver]),l(r,"StatesInviting",[r.States.invite,r.States.state===r.States.quorumReachedTimeRemains]),l(r,"SmallBlinds",[5,10,15,20,25,50,75,100,150,200]),l(r,"KEY_GAME_MODEL","game"),l(r,"KEY_GAME_ID",`${r.KEY_GAME_MODEL}.gameID`),l(r,"KEY_GAME_STATE_ID",`${r.KEY_GAME_MODEL}.stateID`),l(r,"KEY_GAME_SERVER_AUTH_TOKEN",`${r.KEY_GAME_MODEL}.authToken`),l(r,"KEY_GAME_STATE",`${r.KEY_GAME_MODEL}.gameState`),l(r,"KEY_GAME_DECK",`${r.KEY_GAME_MODEL}.deck`),l(r,"KEY_GAME_POTS",`${r.KEY_GAME_MODEL}.pots`),l(r,"KEY_GAME_POT",`${r.KEY_GAME_MODEL}.pot`),l(r,"KEY_GAME_COMMUNITY_CARDS",`${r.KEY_GAME_MODEL}.communityCards`),l(r,"KEY_GAME_PLAYERS",`${r.KEY_GAME_MODEL}.players`),l(r,"KEY_GAME_CURRENT_POSITION",`${r.KEY_GAME_MODEL}.currentPosition`),l(r,"KEY_GAME_BUTTON_POSITION",`${r.KEY_GAME_MODEL}.buttonPosition`),l(r,"KEY_GAME_ROUND",`${r.KEY_GAME_MODEL}.round`),l(r,"KEY_GAME_TOKEN",`${r.KEY_GAME_MODEL}.token`);let h=r;const S=class S extends Y{constructor(t){super(),this.game=t,this.me=t.players[1],this.actions={},this.betActions={},this.raiseActions={},this.lastGoodGameState=null}shuffleUpAndDeal(){const t=this;function s(n){n.handState=f.PlayerHandStates.playing,n.lastAction=f.RoundActions.none,n.hasButton=n.position===t.game.buttonPosition,n.isSmallBlind=n.position===t.game.smallBlindPositon(),n.isBigBlind=n.position===t.game.bigBlindPosition(),n.currentBet=0,n.totalBetsInHand=0,n.currentBets[0]=0,n.totalBetsInPotsInRound[0]=0,n.wentAllInPreviousRound=!1}function e(n){n.handState=f.PlayerHandStates.none,n.lastAction=f.RoundActions.none,n.hasButton=!1,n.isSmallBlind=!1,n.isBigBlind=!1,n.currentCards=[]}if(this.game.deck.shuffle(),this.game.state===h.States.ready){for(const n of this.game.playersStillInGame())n.currentCards=[],n.currentCards.push(this.game.deck.dealCard()),n.currentCards.push(this.game.deck.dealCard());this.game.state=h.States.preFlop}for(const n of this.game.playersStillInGame())s(n);for(const n of this.game.playersOutOfGame())e(n);for(const n of this.game.playersInHand()){n.hasButton&&(this.game.currentPosition=n.position);let a=0;n.isSmallBlind&&(a=Math.min(this.game.smallBlind(),n.stake),n.lastAction=f.RoundActions.smallBlind),n.isBigBlind&&(a=Math.min(this.game.bigBlind(),n.stake),n.lastAction=f.RoundActions.bigBlind),a>0&&this.placeBlindBetForPlayer(a,n)}}determineBet(t){if(Object.keys(S.BetActions).includes(t)){if(t===S.BetActions.call)return this.me.lastAction=f.RoundActions.call,Math.min(this.game.minimumBet(),this.me.stake);if(this.me.lastAction=f.RoundActions.bet,t===S.BetActions.minBet)return Math.min(this.game.minimumBet(),this.me.stake);if(t===S.BetActions.minBetPlus)return Math.min(2*this.game.minimumBet(),this.me.stake);if(t===S.BetActions.betAllIn)return this.me.stake}return this.me.lastAction=f.RoundActions.raise,t===S.RaiseActions.minRaise?Math.min(this.game.minimumRaise(),this.me.stake):t===S.RaiseActions.minRaisePlus?Math.min(this.game.raisePlus(),this.me.stake):this.me.stake}goAllIn(){let t=!1;if(this.game.playersInHand().length>1){this.game.pots.push(new k(0,this.game.playersInHand().map(e=>e.playerID)));for(p of this.game.currentPlayers())p.currentBets.push(0),p.totalBetsInPotsInRound.push(0),p.totalBetsInPotsInHand.push(0);t=!0}const s=this.game.pots.length;for(const e of this.game.playersWhoHaveBetThisRound().filter(n=>!n.equals(this.game.me))){if(e.totalBetsInRound()<=this.me.totalBetsInRound())continue;const n=e.currentBet-this.me.totalBetsInRound();if(s>1&&t)this.game.pots[s-1].amount+=n,this.game.pots[s-2].amount-=n,e.currentBets[s-1]+=n,e.currentBets[s-2]-=n,e.totalBetsInPotsInRound[s-1]+=n,e.totalBetsInPotsInRound[s-2]-=n,e.totalBetsInPotsInHand[s-1]+=n,e.totalBetsInPotsInHand[s-2]-=n;else{let a=n;for(let m=1;m<=this.game.pots.length;++m){let u=this.game.pots.length-m;if(a>0&&f.includes(this.game.playersInPots[u],e)){const c=a>e.currentBets[u]?e.currentBets[u]:a;this.game.pots[u].amount-=c,e.totalBetsInPotsInHand[u]-=c,e.totalBetsInPotsInRound[u]-=c,e.currentBets[u]-=c,a-=c}}e.lastBetInRound-=n,e.stake+=n,e.currentBet-=n}if(e.stake>0)for(const a of this.game.pots)a.addPlayer(e)}}placeBet(t){const s=this.determineBet(t),e=[];for(let a=0;a<this.game.pots.length;++a)e.push(this.game.minimumBetInPot(a));if(this.myLastStake=this.me.stake,this.me.stake-=s,this.me.currentBet=s,this.me.lastBetInRound=s,this.me.totalBetsInHand+=s,this.game.pots.length>1){let a=s;for(let c=0;c<this.game.pots.length-1;++c){const y=this.game.pots[c];let g=e[c];a>=g?(y.amount+=g,this.me.currentBets[c]=g,this.me.totalBetsInPotsInRound[c]+=g,this.me.totalBetsInPotsInHand[c]+=g,a-=g):(y.amount+=a,this.me.currentBets[c]=a,this.me.totalBetsInPotsInRound[c]+=a,this.me.totalBetsInPotsInHand[c]+=a,a=0)}const m=this.game.pots.length-1;let u=this.game.pots[m];a>0?(u.amount+=a,this.me.currentBets[m]=a,this.me.totalBetsInPotsInRound[m]+=a,this.me.totalBetsInPotsInHand[m]+=a,a=0):this.me.stake===0&&this.me.currentBets[m]===0&&u.removePlayer(this.me)}else this.game.pots[0].amount+=s,this.me.currentBets[0]=s,this.me.totalBetsInPotsInRound[0]+=s,this.me.totalBetsInPotsInHand[0]+=s;this.me.stake===0&&this.goAllIn(),this.game.isRoundOver()?this.game.currentPosition=this.game.buttonPosition:this.game.goToNextPosition()}placeBlindBetForPlayer(t,s){const e=[];for(let u=0;u<this.game.pots.length;++u)e.push(this.game.minimumBetInPot(u));s.stake-=t,s.currentBet=t,s.lastBetInRound=t,s.totalBetsInHand+=t;let n=this.game.pots.length;if(n>1){let u=t;for(let c=0;c<this.game.pots.length;++c){let y=this.game.pots[c],g=e[c];u>=g?(y.amount+=g,s.currentBets[c]=g,s.totalBetsInPotsInRound[c]+=g,s.totalBetsInPotsInHand[c]+=g,u-=g):(y.amount+=u,s.currentBets[c]=u,s.totalBetsInPotsInRound[c]+=u,s.totalBetsInPotsInHand[c]+=u,u=0)}}else this.game.pots[0].amount+=t,s.currentBets[0]=t,s.totalBetsInPotsInRound[0]+=t,s.totalBetsInPotsInHand[0]+=t;if(s.stake>0)return;if(this.game.playersInHand().length>1){this.game.pots.push(new k(0,this.game.playersInHand.map(u=>u.playerID)));for(p of this.game.playersInHand())p.currentBets.push(0),p.totalBetsInPotsInRound.push(0),p.totalBetsInPotsInHand.push(0)}n=this.game.pots.length;let a=this.game.playersStillInWhoHaveBetThisRound(),m=a.length;for(const u of a){if(u===s||u.totalBetsInRound()<=u.totalBetsInRound())continue;let c=u.currentBet-u.totalBetsInRound();n>1&&m>1?(this.game.pots[n-1].amount+=c,this.game.pots[n-2].amount-=c,u.currentBets[n-1]+=c,u.currentBets[n-2]-=c,u.totalBetsInPotsInRound[n-1]+=c,u.totalBetsInPotsInRound[n-2]-=c,u.totalBetsInPotsInHand[n-1]+=c,u.totalBetsInPotsInHand[n-2]-=c):(this.game.pots[0].amount-=c,u.totalBetsInPotsInHand[0]-=c,u.totalBetsInPotsInRound[0]-=c,u.lastBetInRound-=c,u.stake+=c,u.currentBets[0]-=c,u.currentBet-=c)}}nextDeal(t=!0){const s={};s[`${h.States.ready}`]="shuffleUpAndDeal",s[`${h.States.preFlop}`]="flop",s[`${h.States.preTurn}`]="turn",s[`${h.States.preRiver}`]="river",(this[s[this.game.state]]||(()=>{}))(t)}flop(t=!0){if(this.game.state!==h.States.preFlop)throw new Error(`Cannot deal flop; state=${this.game.state}`);if(this.game.communityCards.length>0||!this.game.deck.burn())return!1;for(let s=1;s<=3;++s){const e=this.game.deck.dealCard();if(!e)return!1;this.game.communityCards.push(e)}return this.game.state=h.States.preTurn,this.resetForNextRound(t),!0}turn(t=!0){if(this.game.state!==h.States.preTurn)throw new Error(`Cannot deal turn; state=${this.game.state}`);if(this.game.communityCards.length!==3||!this.game.deck.burn())return!1;const s=this.game.deck.dealCard();return s?(this.game.communityCards.push(s),this.game.state=h.States.preRiver,this.resetForNextRound(t),!0):!1}river(t=!0){if(this.game.state!==h.States.preRiver)throw new Error(`Cannot deal river; state=${this.game.state}`);if(this.game.communityCards.length!==4||!this.game.deck.burn())return!1;const s=this.game.deck.dealCard();return s?(this.game.communityCards.push(s),this.game.state=h.States.finalBets,this.resetForNextRound(t),!0):!1}getActions(){const t=this.game.state;if(t==h.States.none||t==h.States.gameOver)return[h.GameActions.newGame];if(t==h.States.ready)return[h.GameActions.deal];if(this.myPosition!=this.game.currentPosition)return[];if(t==h.States.preFlop)return this.me.stake>0?this.game.isRoundOver()?this.game.playersInHand().length>1?[h.GameActions.flop]:[h.GameActions.finish]:[h.GameActions.bet,h.GameActions.fold]:this.game.playersInHand.length>1?[h.GameActions.flop]:[h.GameActions.finish];if(t==h.States.preTurn)if(this.me.stake>0){const s=[];if(!this.game.haveAnyBetsBeenMadeThisRound()&&this.me.lastAction==f.RoundActions.none&&s.push(h.GameActions.check),!this.game.isRoundOver())s.push(h.GameActions.bet,h.GameActions.fold);else return this.game.playersInHand.length>1?[h.GameActions.turn]:[h.GameActions.finish];return s}else return this.game.playersInHand.length>1?[h.GameActions.turn]:[h.GameActions.finish];if(t==h.States.preRiver)if(this.me.stake>0){const s=[];if(!this.game.haveAnyBetsBeenMadeThisRound()&&this.me.lastAction==f.RoundActions.none&&s.push(h.GameActions.check),!this.game.isRoundOver())s.push(h.GameActions.bet,h.GameActions.fold);else return this.game.playersInHand().length>1?[h.GameActions.river]:[h.GameActions.finish];return s}else return this.game.playersInHand().length>1?[h.GameActions.river]:[h.GameActions.finish];if(t==h.States.preRiver){if(this.me.stake>0){const s=[];if(!this.game.haveAnyBetsBeenMadeThisRound()&&this.me.lastAction==f.RoundActions.none&&s.push(h.GameActions.check),!this.game.isRoundOver())s.push(h.GameActions.bet,h.GameActions.fold);else return[h.GameActions.show];return s}return[h.GameActions.show]}return t==h.States.handOver?[h.GameActions.next]:[]}resetForNextRound(t=!0){t&&this.game.goToNextPosition();for(const s of this.game.currentPlayers()){s.lastAction!==f.RoundActions.fold&&(s.stake>0?(s.lastAction=f.RoundActions.none,s.lastBetInRound=0):s.lastAction.isBettingAction()&&(s.wentAllInPreviousRound=!0)),s.currentBet=0;for(let e=0;e<s.currentBets.length;++e)s.currentBets[e]=0,s.totalBetsInPotsInRound[e]=0}}};l(S,"BetActions",{betAllIn:"betAllIn",call:"call",betCancel:"betCancel",minBet:"minBet",minBetPlus:"minBetPlus",raise:"raise"}),l(S,"BetActionStrings",{betAllIn:"All In",call:"Call",betCancel:"Cancel",minBet:"",minBetPlus:"",raise:"Raise"}),l(S,"RaiseActions",{raiseAllIn:"raiseAllIn",raiseCancel:"raiseCancel",minRaise:"minRaise",minRaisePlus:"minRaisePlus"}),l(S,"RaiseActionStrings",{raiseAllIn:"All In",raiseCancel:"Cancel",minRaise:"",minRaisePlus:""}),l(S,"GameActions",{none:"none",newGame:"newGame",deal:"deal",flop:"flop",turn:"turn",river:"river",finish:"finish",show:"show",next:"next",bet:"bet",call:"call",raise:"raise",allIn:"allIn",check:"check",fold:"fold"});let C=S;const b=({card:B})=>E.jsx(E.Fragment,{children:E.jsx("span",{children:B.toString()})}),F=({player:B,isBot:t=!1})=>{const s=B;return E.jsxs(E.Fragment,{children:[E.jsx("span",{children:s.pokerFace}),E.jsxs("span",{children:["Stake $",s.stake]}),E.jsx("p",{children:s.currentCards.map(e=>E.jsx(b,{card:e},e.toString()))}),!t&&E.jsx("button",{children:"Bet"})]})},$=({pot:B})=>E.jsx(E.Fragment,{children:E.jsx("span",{children:B.amount})}),H=({game:B})=>E.jsxs(E.Fragment,{children:[E.jsx("p",{children:B.communityCards.map(t=>E.jsx(b,{card:t},t.toString()))}),E.jsx("p",{children:B.pots.map((t,s)=>E.jsx($,{pot:t},s))})]}),_=()=>{let[B,t]=v.useState(()=>new h(2));const s=new C(B),e=()=>{s.nextDeal(),t(h.fromJSON(s.game.toJSON()))};return E.jsxs("div",{className:"card-table",children:[E.jsxs("div",{className:"card-table-header",children:[E.jsx("span",{className:"card-table-header-blind-value",children:s.game.smallBlind()}),E.jsx("span",{className:"card-table-header-blind-value",children:s.game.bigBlind()})]}),E.jsxs("div",{className:"card-table-header",children:[E.jsx("span",{className:"card-table-header-blind-label",children:"Small Blind"}),E.jsx("span",{className:"card-table-header-blind-label",children:"Big Blind"})]}),E.jsx("button",{children:"New Game"}),E.jsx("div",{children:"bets"}),E.jsx("div",{children:E.jsx(H,{game:s.game})}),E.jsx("div",{children:E.jsx("button",{onClick:e,children:"Deal"})}),s.game.players.map((n,a)=>E.jsx(F,{player:n,isBot:a===0},n.playerID))]})};w.createRoot(document.getElementById("root")).render(E.jsx(M.StrictMode,{children:E.jsx(_,{})}));
