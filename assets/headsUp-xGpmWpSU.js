var f=Object.defineProperty;var k=(u,t,e)=>t in u?f(u,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[t]=e;var c=(u,t,e)=>k(u,typeof t!="symbol"?t+"":t,e);import{j as d,c as x,R as g}from"./client-CADlzgmn.js";const a=class a{static exclude(t,e){return e.filter(s=>!s.equals(t))}static highestCardInSubset(t){return t.toSorted((e,s)=>s.lt(e))[0]}static highestCardInSubsets(t,e){if(t.length===0||e.length===0)return null;const s=a.highestCardInSubset(t),r=a.highestCardInSubset(e);return s.equals(r)?a.highestCardInSubsets(a.exclude(s,t),a.exclude(r,e)):Math.max(s.value(),r.value())}static fromJSON(t){return new a(t.suit,t.rank)}static isHighCardLess(t,e){if(t.length===0||e.length===0)return!1;const s=a.highestCardInSubset(t),r=a.highestCardInSubset(e);return s.lt(r)?!0:r.lt(s)?!1:a.isHighCardLess(a.exclude(s,t),a.exclude(r,e))}constructor(t,e){this.suit=a.Suits[t],this.rank=a.Ranks[e]}equals(t){return this.value()===t.value()}isSameAsCard(t){return self.equals(t)&&self.suit===t.suit}lowValue(){return a.LowValues[self.rank]}lt(t){return this.value()<t.value()}value(){return a.Values[self.rank]}toString(){return this.suit+this.rank}toJSON(){return{suit:this.suit,rank:this.rank}}};c(a,"Suits",{club:"♣️",diamond:"♦️",heart:"♥️",spade:"♠️"}),c(a,"Ranks",{deuce:"2",trey:"3",four:"4",five:"5",six:"6",seven:"7",eight:"8",nine:"9",ten:"10",jack:"J",queen:"Q",king:"K",ace:"A"}),c(a,"Values",{deuce:2,trey:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10,jack:11,queen:12,king:13,ace:14}),c(a,"LowValues",{deuce:2,trey:3,four:4,five:5,six:6,seven:7,eight:8,nine:9,ten:10,jack:11,queen:12,king:13,ace:1});let n=a;class S{static randomIndicesForArrayOfSize(t){const e=[],s=new Array(t).fill(0);let r=0;for(let l=0;l<t;++l){const h=Math.floor(Math.random()*(t-l));e.push(s[h]),r=s[h],s[h]=s[t-l-1],s[t-l-1]=r}return e}}const i=class i{constructor(){this.cards=[],this.discards=[],this.dealtCards=[],this.deckIndex=0;for(const t in i.availableSuits)for(const e in i.availableRanks)this.cards.append(new n(t,e))}currentCard(){return this.deckIndex<this.cards.length?this.cards[this.deckIndex]:null}hasAllCards(){let t=this.cards.length===i.availableSuits.length*i.availableRanks.length;if(!t)return!1;for(const e in i.availableSuits)for(const s in i.availableRanks)t=t&&this.cards.contains(new n(e,s));return t}shuffle(){this.dealtCards=[];const t=S.randomIndicesForArrayOfSize(this.cards.length),e=[];for(let s=0;s<this.cards.length;++s)e.push(this.cards[t[s]]);this.cards=e,this.reset()}burn(t=1){if(this.deckIndex+t>this.cards.length)return null;const e=[];for(let s=1;s<=t;++s){const r=this.cards[this.deckIndex];this.discards.push(r),e.push(r),this.deckIndex+=1}return e}dealCard(){if(this.deckIndex+1>this.cards.count)return null;const t=this.cards[this.deckIndex];return this.dealtCards.append(t),this.deckIndex+=1,t}reset(){this.dealtCards=[],this.deckIndex=0,this.discards=[]}toString(){return`${this.cards}`}};c(i,"availableSuits",[n.Suits.club,n.Suits.diamond,n.Suits.heart,n.Suits.spade]),c(i,"availableRanks",[n.Ranks.ace,n.Ranks.deuce,n.Ranks.trey,n.Ranks.four,n.Ranks.five,n.Ranks.six,n.Ranks.seven,n.Ranks.eight,n.Ranks.nine,n.Ranks.ten,n.Ranks.jack,n.Ranks.queen,n.Ranks.king]);let o=i;const v=()=>{const u=new o;return d.jsxs(d.Fragment,{children:[d.jsx("h1",{children:"Heads Up!"}),d.jsx("div",{children:"bets"}),d.jsx("div",{children:"board"}),d.jsx("div",{children:u.toString()})]})};x.createRoot(document.getElementById("root")).render(d.jsx(g.StrictMode,{children:d.jsx(v,{})}));
